import{gZ as z,hf as R,R as T,d7 as I}from"./calcite-c5ae4991.js";function p(d,t){return[d,t]}function C(d,t,o){return d[0]=t,d[1]=o,d}function L(d,t,o,l,e){return d[0]=t,d[1]=o,d[2]=l,d[3]=e,d}const F=new z("0/0/0/0");class S{static create(t,o,l=null){const e=R(t.spatialReference),i=o.origin||p(t.origin.x,t.origin.y),r=p(t.size[0]*o.resolution,t.size[1]*o.resolution),s=p(-1/0,-1/0),n=p(1/0,1/0),a=p(1/0,1/0);T(l)&&(C(s,Math.max(0,Math.floor((l.xmin-i[0])/r[0])),Math.max(0,Math.floor((i[1]-l.ymax)/r[1]))),C(n,Math.max(0,Math.floor((l.xmax-i[0])/r[0])),Math.max(0,Math.floor((i[1]-l.ymin)/r[1]))),C(a,n[0]-s[0]+1,n[1]-s[1]+1));const{cols:f,rows:g}=o;let M,y,v,u;return!l&&f&&g&&(C(s,f[0],g[0]),C(n,f[1],g[1]),C(a,f[1]-f[0]+1,g[1]-g[0]+1)),t.isWrappable?(M=p(Math.ceil(Math.round((e.valid[1]-e.valid[0])/o.resolution)/t.size[0]),a[1]),y=p(Math.floor((e.origin[0]-i[0])/r[0]),s[1]),v=p(M[0]+y[0]-1,n[1]),u=!0):(y=s,v=n,M=a,u=!1),new S(o.level,o.resolution,o.scale,i,s,n,a,r,y,v,M,u)}constructor(t,o,l,e,i,r,s,n,a,f,g,M){this.level=t,this.resolution=o,this.scale=l,this.origin=e,this.first=i,this.last=r,this.size=s,this.norm=n,this.worldStart=a,this.worldEnd=f,this.worldSize=g,this.wrap=M}normalizeCol(t){if(!this.wrap)return t;const o=this.worldSize[0];return t<0?o-1-Math.abs((t+1)%o):t%o}denormalizeCol(t,o){return this.wrap?this.worldSize[0]*o+t:t}getWorldForColumn(t){return this.wrap?Math.floor(t/this.worldSize[0]):0}getFirstColumnForWorld(t){return t*this.worldSize[0]+this.first[0]}getLastColumnForWorld(t){return t*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(t){return(t-this.origin[0])/this.norm[0]}getXForColumn(t){return this.origin[0]+t*this.norm[0]}getRowForY(t){return(this.origin[1]-t)/this.norm[1]}getYForRow(t){return this.origin[1]-t*this.norm[1]}getTileBounds(t,o,l=!1){F.set(o);const e=l?F.col:this.denormalizeCol(F.col,F.world),i=F.row;return L(t,this.getXForColumn(e),this.getYForRow(i+1),this.getXForColumn(e+1),this.getYForRow(i)),t}getTileCoords(t,o,l=!1){F.set(o);const e=l?F.col:this.denormalizeCol(F.col,F.world);return Array.isArray(t)?C(t,this.getXForColumn(e),this.getYForRow(F.row)):(t.x=this.getXForColumn(e),t.y=this.getYForRow(F.row)),t}}let _=class{constructor(){this.spans=[]}acquire(t){this.lodInfo=t}release(){this.lodInfo=null,this.spans.length=0}forEach(t,o){const{spans:l,lodInfo:e}=this,{level:i}=e;if(l.length!==0)for(const{row:r,colFrom:s,colTo:n}of l)for(let a=s;a<=n;a++)t.call(o,i,r,e.normalizeCol(a),e.getWorldForColumn(a))}};_.pool=new I(_);class B{constructor(t,o,l){this.row=t,this.colFrom=o,this.colTo=l}}const c=new z("0/0/0/0");class x{static create(t,o){t[1]>o[1]&&([t,o]=[o,t]);const[l,e]=t,[i,r]=o,s=i-l,n=r-e,a=n!==0?s/n:0,f=(Math.ceil(e)-e)*a,g=(Math.floor(e)-e)*a;return new x(l,Math.floor(e),Math.ceil(r),a,s<0?f:g,s<0?g:f,s<0?i:l,s<0?l:i)}constructor(t,o,l,e,i,r,s,n){this.x=t,this.ymin=o,this.ymax=l,this.invM=e,this.leftAdjust=i,this.rightAdjust=r,this.leftBound=s,this.rightBound=n}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}}const w=[[0,0],[0,0],[0,0],[0,0]],X=1e-6;class W{constructor(t,o=null){this.tileInfo=t,this.fullExtent=o,this.scales=[],this._infoByScale={},this._infoByLevel={};const l=t.lods.slice();l.sort((i,r)=>r.scale-i.scale);const e=this._lodInfos=l.map(i=>S.create(t,i,o));l.forEach((i,r)=>{this._infoByLevel[i.level]=e[r],this._infoByScale[i.scale]=e[r],this.scales[r]=i.scale},this),this._wrap=t.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(t){return this._infoByLevel[typeof t=="number"?t:t.level]}getTileBounds(t,o,l=!1){c.set(o);const e=this._infoByLevel[c.level];return e?e.getTileBounds(t,c,l):t}getTileCoords(t,o,l=!1){c.set(o);const e=this._infoByLevel[c.level];return e?e.getTileCoords(t,c,l):t}getTileCoverage(t,o=192,l="closest"){const e=l==="closest"?this.getClosestInfoForScale(t.scale):this.getSmallestInfoForScale(t.scale),i=_.pool.acquire(e),r=this._wrap;let s,n,a,f=1/0,g=-1/0;const M=i.spans;w[0][0]=w[0][1]=w[1][1]=w[3][0]=-o,w[1][0]=w[2][0]=t.size[0]+o,w[2][1]=w[3][1]=t.size[1]+o;for(const h of w)t.toMap(h,h),h[0]=e.getColumnForX(h[0]),h[1]=e.getRowForY(h[1]);const y=[];let v=3;for(let h=0;h<4;h++){if(w[h][1]===w[v][1]){v=h;continue}const m=x.create(w[h],w[v]);f=Math.min(m.ymin,f),g=Math.max(m.ymax,g),y[m.ymin]===void 0&&(y[m.ymin]=[]),y[m.ymin].push(m),v=h}if(f==null||g==null||g-f>100)return null;let u=[];for(s=f;s<g;){y[s]!=null&&(u=u.concat(y[s])),n=1/0,a=-1/0;for(let h=u.length-1;h>=0;h--){const m=u[h];n=Math.min(n,m.getLeftCol()),a=Math.max(a,m.getRightCol())}if(n=Math.floor(n),a=Math.floor(a),s>=e.first[1]&&s<=e.last[1])if(r)if(e.size[0]<e.worldSize[0]){const h=Math.floor(a/e.worldSize[0]);for(let m=Math.floor(n/e.worldSize[0]);m<=h;m++)M.push(new B(s,Math.max(e.getFirstColumnForWorld(m),n),Math.min(e.getLastColumnForWorld(m),a)))}else M.push(new B(s,n,a));else n>e.last[0]||a<e.first[0]||(n=Math.max(n,e.first[0]),a=Math.min(a,e.last[0]),M.push(new B(s,n,a)));s+=1;for(let h=u.length-1;h>=0;h--){const m=u[h];m.ymax>=s?m.incrRow():u.splice(h,1)}}return i}getTileParentId(t){c.set(t);const o=this._infoByLevel[c.level],l=this._lodInfos.indexOf(o)-1;return l<0?null:(this._getTileIdAtLOD(c,this._lodInfos[l],c),c.id)}getTileResolution(t){const o=this._infoByLevel[typeof t=="object"?t.level:t];return o?o.resolution:-1}getTileScale(t){const o=this._infoByLevel[t.level];return o?o.scale:-1}intersects(t,o){c.set(o);const l=this._infoByLevel[c.level],e=t.lodInfo;if(e.resolution>l.resolution){this._getTileIdAtLOD(c,e,c);const r=e.denormalizeCol(c.col,c.world);for(const s of t.spans)if(s.row===c.row&&s.colFrom<=r&&s.colTo>=r)return!0}if(e.resolution<l.resolution){const[r,s,n,a]=t.spans.reduce((u,h)=>(u[0]=Math.min(u[0],h.row),u[1]=Math.max(u[1],h.row),u[2]=Math.min(u[2],h.colFrom),u[3]=Math.max(u[3],h.colTo),u),[1/0,-1/0,1/0,-1/0]),f=l.denormalizeCol(c.col,c.world),g=e.getColumnForX(l.getXForColumn(f)),M=e.getRowForY(l.getYForRow(c.row)),y=e.getColumnForX(l.getXForColumn(f+1))-1,v=e.getRowForY(l.getYForRow(c.row+1))-1;return!(g>a||y<n||M>s||v<r)}const i=e.denormalizeCol(c.col,c.world);return t.spans.some(r=>r.row===c.row&&r.colFrom<=i&&r.colTo>=i)}normalizeBounds(t,o,l){if(t[0]=o[0],t[1]=o[1],t[2]=o[2],t[3]=o[3],this._wrap){const e=R(this.tileInfo.spatialReference),i=-l*(e.valid[1]-e.valid[0]);t[0]+=i,t[2]+=i}return t}getSmallestInfoForScale(t){const o=this.scales;if(this._infoByScale[t])return this._infoByScale[t];if(t>o[0])return this._infoByScale[o[0]];for(let l=1;l<o.length-1;l++)if(t>o[l]+X)return this._infoByScale[o[l-1]];return this._infoByScale[o[o.length-1]]}getClosestInfoForScale(t){const o=this.scales;return this._infoByScale[t]||(t=o.reduce((l,e)=>Math.abs(e-t)<Math.abs(l-t)?e:l,o[0])),this._infoByScale[t]}scaleToLevel(t){const o=this.scales;if(this._infoByScale[t])return this._infoByScale[t].level;for(let l=o.length-1;l>=0;l--)if(t<o[l])return l===o.length-1?this._infoByScale[o[o.length-1]].level:this._infoByScale[o[l]].level+(o[l]-t)/(o[l]-o[l+1]);return this._infoByScale[o[0]].level}scaleToZoom(t){return this.tileInfo.scaleToZoom(t)}_getTileIdAtLOD(t,o,l){const e=this._infoByLevel[l.level];return t.set(l),o.resolution<e.resolution?null:(o.resolution===e.resolution||(t.level=o.level,t.col=Math.floor(l.col*e.resolution/o.resolution+.01),t.row=Math.floor(l.row*e.resolution/o.resolution+.01)),t)}}export{W as h,_ as l};
