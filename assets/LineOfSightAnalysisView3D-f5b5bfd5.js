import{e as n,y as o,aw as u,a as V,v as L,f as _,ax as et,t as mt,oc as Ut,be as Bt,eO as Wt,cm as Jt,$ as h,R as d,q as P,z as yt,k as W,u as J,p as _t,a6 as kt,b8 as Ct,eq as wt,aa as K,b2 as it,x as qt,m as tt,bQ as B,M as Zt,aW as Ot,fE as nt,ic as ot,h as D,aj as Tt,af as Kt,hO as Qt,eA as zt,a8 as Xt,cB as Yt,db as te,o5 as It,od as ee,e1 as ie,nZ as Q,l as ne,ba as oe,ai as k,dV as xt,oe as ut,of as Pt,lB as Vt,cc as x,j as se}from"./calcite-c5ae4991.js";import{a as Lt,g as ct,b as re}from"./LineVisualElement-520cb14e.js";import{l as pt,u as St,f as Rt}from"./LineOfSightAnalysisTarget-47ff196f.js";import{j as ae,d as Ft,t as le,k as ht,h as bt}from"./sphere-5ce3b13c.js";import{b as Et,f as de,g as ue}from"./elevationInfoUtils-def3e352.js";import{R as ce}from"./dehydratedFeatures-ce9ee959.js";import{x as pe,t as dt,aC as he,aJ as ge,w as X,aK as ve,aL as lt,aM as me,aN as ye,aw as _e}from"./MediaLayerVideo-b25b4fca.js";import{v as be,b as fe}from"./Util-2b929b00.js";import{i as Ce,e as we,R as Oe,c as Te,a as At,s as Ie,m as Pe}from"./analysisViewUtils-ad794640.js";import{d as Ve,S as $t}from"./PointVisualElement-e21f219e.js";import{e as Le}from"./mat4f64-abdda1bb.js";import{ak as gt}from"./objectResourceUtils-8fb711c9.js";import"./index-9a6385f7.js";import"./persistable-aa8e873d.js";import"./multiOriginJSONSupportUtils-c978f4c3.js";import"./resourceExtension-a1892050.js";import"./mat3f64-50f3b9f6.js";import"./quatf64-f8f1c132.js";import"./quantizationUtils-a15bd53f.js";import"./plane-6ecad71b.js";import"./spatialReferenceEllipsoidUtils-87122df3.js";import"./scaleUtils-a8d07219.js";import"./ElevationSamplerData-41a54d7d.js";import"./OrderIndependentTransparency-5f7257d7.js";import"./enums-e2e92c86.js";import"./basicInterfaces-7449a8bf.js";import"./VertexAttribute-15d1866a.js";import"./vec3f32-01c06d8d.js";import"./FramebufferObject-d9042b3f.js";import"./Texture-3d2bcec7.js";import"./Octree-65a3a6a2.js";import"./edgeProcessing-fca251f2.js";import"./deduplicate-54cc928a.js";import"./Indices-84de656e.js";import"./InterleavedLayout-45bbbdfe.js";import"./BufferView-bc307796.js";import"./types-e1c0a5bf.js";import"./VertexElementDescriptor-2925c6af.js";import"./symbolColorUtils-14fb8f64.js";import"./MeshComponent-9e26db57.js";import"./earcut-61f7b102.js";import"./imageUtils-c2d0d1ae.js";import"./projection-425e8064.js";import"./quat-8dcd84de.js";import"./vec33-164586fc.js";import"./NestedMap-1b5db22e.js";import"./ZoomMomentumEstimator-f0d7cb62.js";import"./floatRGBA-2dd25736.js";import"./labelFormatUtils-2486d06e.js";import"./orientedBoundingBox-d2c06194.js";import"./quatf32-51a323b8.js";import"./SnappingCandidate-970faec6.js";import"./callExpressionWithFeature-94cb1131.js";import"./resourceUtils-527631ac.js";import"./DefaultVertexAttributeLayouts-5f20d8dd.js";import"./geometryServiceUtils-b1997a16.js";import"./project-0e0370f9.js";import"./DefaultMaterial_COLOR_GAMMA-941dbf6c.js";import"./Version-e2fa8281.js";import"./LercDecoder-25ed2639.js";import"./VectorTile-ade0a955.js";import"./enums-fb086c25.js";import"./config-1337d16e.js";import"./TiledDisplayObject-0268aa47.js";import"./DisplayObject-b5071d0a.js";import"./rasterUtils-0aabb0e8.js";import"./requestImageUtils-67552ee5.js";import"./resources-4ce48b80.js";import"./workerHelper-33dafb63.js";import"./webgl-debug-7f880832.js";import"./RenderingContext-f0258ff2.js";import"./ProgramCache-ddf14e3e.js";import"./Program-2221c2b1.js";import"./doublePrecisionUtils-e3c3d0d8.js";import"./MediaLayer-faedb24a.js";import"./MediaElementView-92573d58.js";import"./normalizeUtilsSync-f9670301.js";import"./BoundsStore-32c0ea98.js";import"./PooledRBush-52d39e88.js";import"./prism-line-numbers-713161a8.js";import"./label2-e5a29f4c.js";import"./interactive-1de2e238.js";import"./loadable-6afd516d.js";import"./t9n-b59ffad1.js";import"./observers-c89705b8.js";import"./icon-179b3e31.js";import"./loader-dc9b20b1.js";import"./guid-51402ee7.js";import"./ImageMaterial-b8486f1d.js";import"./VisualElementResources-de04f9e5.js";import"./devEnvironmentUtils-5002a058.js";let A=class extends L{constructor(e){super(e),this.innerWidth=2,this.outerWidth=8,this.visibleInnerColor=new u([3,252,111,1]),this.visibleOuterColor=new u([3,252,111,.15]),this.occludedInnerColor=new u([252,3,69,1]),this.occludedOuterColor=new u([252,3,69,.1]),this.undefinedInnerColor=new u([255,255,255,1]),this.undefinedOuterColor=new u([127,127,127,.2])}};n([o({type:Number})],A.prototype,"innerWidth",void 0),n([o({type:Number})],A.prototype,"outerWidth",void 0),n([o({type:u})],A.prototype,"visibleInnerColor",void 0),n([o({type:u})],A.prototype,"visibleOuterColor",void 0),n([o({type:u})],A.prototype,"occludedInnerColor",void 0),n([o({type:u})],A.prototype,"occludedOuterColor",void 0),n([o({type:u})],A.prototype,"undefinedInnerColor",void 0),n([o({type:u})],A.prototype,"undefinedOuterColor",void 0),A=n([V("esri.views.3d.analysis.LineOfSight.LineOfSightConfiguration")],A);let F=class extends L{constructor(e){super(e),this.target=null,this.intersectedGraphic=null,this.intersectedLocation=null,this.elevationAlignedTargetLocation=null,this.visible=void 0}};n([o()],F.prototype,"target",void 0),n([o()],F.prototype,"intersectedGraphic",void 0),n([o()],F.prototype,"intersectedLocation",void 0),n([o()],F.prototype,"elevationAlignedTargetLocation",void 0),n([o({type:Boolean})],F.prototype,"visible",void 0),F=n([V("esri.views.3d.analysis.LineOfSightAnalysisResult")],F);let G=class extends L{constructor(t){super(t),this.elevationAlignedTargetLocation=null,this.inputPoints={isValid:!1,observer:_(),observerSurfaceNormal:null,observerFeatureId:null,target:_(),targetSurfaceNormal:null,targetFeatureId:null,observerAdjusted:_(),targetAdjusted:_()},this.computationResult={start:_(),end:_(),intersection:_(),isValid:!1,isTargetVisible:!1},this.result=null}notifyResultChanged(){this.notifyChange("computationResult")}notifyInputPointsChanged(){this.notifyChange("inputPoints")}};n([o()],G.prototype,"target",void 0),n([o()],G.prototype,"elevationAlignedTargetLocation",void 0),n([o()],G.prototype,"inputPoints",void 0),n([o()],G.prototype,"computationResult",void 0),n([o()],G.prototype,"result",void 0),G=n([V("esri.views.3d.analysis.LineOfSight.LineOfSightComputation")],G);var ft;let R=ft=class extends L{constructor(t){super(t)}clone(){return new ft({type:this.type,id:et(this.id),mapPoint:et(this.mapPoint),renderPoint:mt(this.renderPoint),normal:et(this.normal),ray:et(this.ray),graphic:this.graphic})}equals(t){return this.type===t.type&&this.id===t.id&&Ut(this.mapPoint,t.mapPoint)&&Bt(this.renderPoint,t.renderPoint)&&Wt(this.normal,t.normal)&&ae(this.ray,t.ray)&&this.graphic===t.graphic}};n([o()],R.prototype,"type",void 0),n([o({constructOnly:!0})],R.prototype,"id",void 0),n([o({constructOnly:!0})],R.prototype,"mapPoint",void 0),n([o({constructOnly:!0})],R.prototype,"renderPoint",void 0),n([o({constructOnly:!0})],R.prototype,"normal",void 0),n([o({constructOnly:!0})],R.prototype,"graphic",void 0),n([o({constructOnly:!0})],R.prototype,"ray",void 0),R=ft=n([V("esri.views.3d.analysis.LineOfSight.LineOfSightIntersectionResult")],R);let q=class extends L{constructor(t){super(t),this._terrainIntersectionOptionsLayerUids=new Set(["terrain"])}initialize(){this.intersector=pe(this.view.state.viewingMode),this.intersector.options.hud=!1,this.intersector.options.store=dt.MIN}getScreenPointIntersection(t){const e=Jt(t,le.get()),i=he(this.view.state.camera,e,vt);return this._getRayIntersection(i)}_getRayIntersection(t,e){if(h(t)||h(this.view.sceneIntersectionHelper))return null;this.intersector.options.store=dt.MIN,this.view.sceneIntersectionHelper.intersectToolIntersectorRay(t,this.intersector,e);const i=this.intersector.results.min,s=_();if(!i.getIntersectionPoint(s))return null;const r=this.view.renderCoordsHelper.fromRenderCoords(s,this.view.spatialReference),l=mt(i.normal);if(ge(i))return new R({type:X.OBJECT,id:`${i.target.layerUid}/${i.target.nodeIndex}/${i.target.componentIndex}`,mapPoint:r,renderPoint:s,normal:l,ray:ht(t),graphic:null});if(ve(i))return new R({type:X.TERRAIN,id:i.target.lij.slice(),mapPoint:r,renderPoint:s,normal:l,ray:ht(t),graphic:null});const a=lt(i,this.view);if(d(a)){const v=a.layer,g=a.sourceLayer;let p;return g&&g.type==="scene"?p=ce(a,g.objectIdField):p=a.uid,new R({type:X.OBJECT,id:`${v==null?void 0:v.uid}/${p}`,mapPoint:r,renderPoint:s,normal:l,ray:ht(t),graphic:a})}return null}updateFromGroundIntersection(t,e,i){const s=Se,r=Re,l=Ee,a=Ae;P(r,t),this.view.renderCoordsHelper.worldUpAtPosition(r,l),yt(l,l);const v=this.view.basemapTerrain.visibleElevationBounds,g=v?Math.abs(v.max-v.min):100,p=e>=0?1:-1;W(a,l,p*(g+Math.abs(e))),J(s,r,a),bt(s,r,vt);const c=this._getRayIntersection(vt,{include:this._terrainIntersectionOptionsLayerUids});return d(c)?(W(a,l,p*e),J(i,c.renderPoint,a),mt(c.normal)):(P(i,t),null)}};n([o()],q.prototype,"view",void 0),n([o()],q.prototype,"intersector",void 0),q=n([V("esri.views.3d.analysis.LineOfSight.LineOfSightRayIntersector")],q);const Se=_(),Re=_(),Ee=_(),Ae=_(),vt=Ft(),Gt="esri.views.3d.analysis.LineOfSight.LineOfSightController",Ht=_t.getLogger(Gt);let f=class extends kt.EventedMixin(L){constructor(t){super(t),this.updateOnCameraChange=!0,this._observerGroundOffsetRenderSpace=0,this._effectiveObserverElevationMode="absolute-height",this._observerFeatureId=null,this._updatingHandles=new Ct,this._frameTask=wt,this._handles=new K,this._computationHandles=new K,this._externalObserverUpdate=!0}initialize(){var e;const t=(e=this.view.resourceController)==null?void 0:e.scheduler;this._frameTask=t?t.registerTask(it.LINE_OF_SIGHT_TOOL):wt,this._intersector=new q({view:this.view}),this._handles.add([this._connectObserver(),this._connectComputations(),this._connectTargets()])}destroy(){this._handles.destroy(),this._computationHandles.destroy(),this._computations.removeAll(),this._updatingHandles.destroy()}get updating(){return this._frameTask.updating||this._updatingHandles.updating}get priority(){return this._frameTask.priority}set priority(t){this._frameTask.priority=t}get _computations(){return this.analysisViewData.computations}get _elevationAlignedObserverPositionRenderSpace(){return this.analysisViewData.observerEngineLocation}set _elevationAlignedObserverPositionRenderSpace(t){this.analysisViewData.observerEngineLocation=t}get _screenPixelSize(){return this.view.state.camera.computeScreenPixelSizeAt(this._elevationAlignedObserverPositionRenderSpace)}_computeResult(t){const e=t.computation,{inputPoints:i,computationResult:s}=e,{observerAdjusted:r,targetAdjusted:l}=i,{start:a,end:v}=s;P(a,r),P(v,l),this._canCompute(e)?this._computeIntersection(t):this._interpolateIntersection(t),e.notifyResultChanged(),this.emit("result-changed",{target:t.computation.target,result:e.result})}_updateAdjustedPointsFromFeatures(t){const e=this.view,{sceneIntersectionHelper:i}=e,{inputPoints:s}=t,{observerAdjusted:r,observerFeatureId:l,targetFeatureId:a,targetAdjusted:v}=s;if(h(l)&&h(a))return;const g=qt(r,v),p=this._intersector.intersector,c=bt(s.observer,s.target,Mt);p.options.store=dt.ALL,i.intersectToolIntersectorRay(c,p);let y=null,m=null,w=null,I=null;for(const T of p.results.all){const b=lt(T,this.view);if(h(b)||h(T.distanceInRenderSpace))continue;const E=pt(b);h(E)||(d(l)&&E===l&&(h(y)&&(y=this._getFeatureDistanceThreshold(T,e,g)),T.distanceInRenderSpace<y&&(w=T)),d(a)&&E===a&&(h(m)&&(m=this._getFeatureDistanceThreshold(T,e,g)),h(I)&&T.distanceInRenderSpace<g&&g-T.distanceInRenderSpace<m&&(I=T)))}d(w)&&w.getIntersectionPoint(r)&&(s.observerSurfaceNormal=w.getTransformedNormal(_())),d(I)&&I.getIntersectionPoint(v)&&(s.targetSurfaceNormal=I.getTransformedNormal(_()))}_getFeatureDistanceThreshold(t,e,i){if(me(t)){const s=ye(t,e);if(d(s))return Math.min(s*He,i)}return 1e-5*i}_adjustStartEndPositions(t){const e=this._screenPixelSize,i=this.view,{inputPoints:s}=t,{observer:r,observerSurfaceNormal:l,target:a,targetSurfaceNormal:v,observerAdjusted:g,targetAdjusted:p}=s,c=st;P(g,r),P(p,a),this._updateAdjustedPointsFromFeatures(t),d(l)?P(c,l):tt(c,p,g);const y=e;yt(c,c),W(c,c,Math.min(y,1)),J(g,g,c),d(v)?P(c,v):tt(c,g,p);const m=i.state.camera.computeScreenPixelSizeAt(p);yt(c,c),W(c,c,Math.min(m,1)),J(p,p,c)}_computeIntersection({computation:t,interpolationInfo:e}){const{view:i}=this,{sceneIntersectionHelper:s,renderCoordsHelper:r}=i;if(h(s))return;const l=this._intersector.intersector,{computationResult:a,inputPoints:v}=t,{observer:g,target:p}=v,{start:c,end:y}=a,m=bt(c,y,Mt);l.options.store=dt.MIN,s.intersectToolIntersectorRay(m,l);const w=l.results.min,I=a.intersection,T=st;let b=!0;if(d(w)&&w.getIntersectionPoint(I)){P(e.originalIntersection,I),P(e.originalObserver,c),P(e.originalTarget,y),r.fromRenderCoords(I,T,i.spatialReference);const S=1-B(y,p)/B(c,p);b=B(g,I)>=S*B(g,p)}const E=new Zt(T,i.spatialReference);{const{result:S,target:z}=t;d(S)?(S.target=z,S.intersectedGraphic=b?null:lt(w,i),S.intersectedLocation=b?null:E,S.visible=b):t.result=new F({target:z,elevationAlignedTargetLocation:t.elevationAlignedTargetLocation,intersectedGraphic:b?null:lt(w,i),intersectedLocation:b?null:E,visible:b})}a.isValid=v.isValid=!0,a.isTargetVisible=b}_interpolateIntersection({computation:t,interpolationInfo:e}){const{computationResult:i,inputPoints:s}=t,{start:r,end:l,intersection:a}=i,{originalIntersection:v,originalObserver:g,originalTarget:p}=e;if(P(a,v),s.isValid){const c=st,y=B(g,v)/B(g,p);Ot(c,r,g),W(c,c,1-y),J(a,a,c),Ot(c,l,p),W(c,c,y),J(a,a,c),i.isValid=!0}else t.result=null,i.isValid=!1,i.isTargetVisible=!1}_canCompute(t){const e=this.analysisViewData.elevationAlignedObserver,i=this.view.frustum;if(h(e)||h(t.elevationAlignedTargetLocation)||h(i))return!1;const{observerAdjusted:s,targetAdjusted:r}=t.inputPoints,l=i.intersectsPoint(s),a=i.intersectsPoint(r);return l&&a}_onObserverPositionChange(t,e,i,s,r){if(this._externalObserverUpdate=r,h(t))return this.analysisViewData.elevationAlignedObserver=null,void(this._observerFeatureId=null);if(h(e))return Lt(this.analysis,t.spatialReference,Ht),void(this.analysisViewData.elevationAlignedObserver=null);const l=this._getEffectiveElevationInfo(e,i),{absoluteZ:a,elevation:v}=Et(e.x,e.y,e.z,this.view.spatialReference,this.view,l),g=e.clone();g.z=a,this._effectiveObserverElevationMode=l.mode,this.analysisViewData.elevationAlignedObserver=g;const p=_();this.view.renderCoordsHelper.toRenderCoords(g,p),this._elevationAlignedObserverPositionRenderSpace=p,this._observerGroundOffsetRenderSpace=a-v,this._observerFeatureId=pt(s),this.priority=it.LINE_OF_SIGHT_TOOL_INTERACTIVE}_onObserverRenderSpacePositionChangeForComputation(t,e,i,s,r){const{inputPoints:l}=t;switch(P(l.observer,e),l.observerFeatureId=r,l.observerSurfaceNormal=null,s){case"on-the-ground":case"relative-to-ground":{const a=this._intersector.updateFromGroundIntersection(l.observer,i,l.observer);h(l.observerFeatureId)&&(l.observerSurfaceNormal=a)}}this._adjustStartEndPositions(t),t.notifyInputPointsChanged(),this.priority=it.LINE_OF_SIGHT_TOOL_INTERACTIVE}_onTargetPositionChange(t,e,i,s,r,l=!0){const a=t.inputPoints;if(l&&(a.isValid=!1),h(i))return d(e)&&Lt(this.analysis,e.spatialReference,Ht),t.elevationAlignedTargetLocation=null,void t.notifyInputPointsChanged();const v=this._getEffectiveElevationInfo(i,s),{absoluteZ:g,elevation:p}=Et(i.x,i.y,i.z,this.view.spatialReference,this.view,v),c=i.clone();switch(c.z=g,t.elevationAlignedTargetLocation=c,this.view.renderCoordsHelper.toRenderCoords(t.elevationAlignedTargetLocation,a.target),a.targetFeatureId=pt(r),a.targetSurfaceNormal=null,v.mode){case"on-the-ground":case"relative-to-ground":{const y=this._intersector.updateFromGroundIntersection(a.target,g-p,a.target);h(a.targetFeatureId)&&(a.targetSurfaceNormal=y)}}this._adjustStartEndPositions(t),t.notifyInputPointsChanged(),this.priority=it.LINE_OF_SIGHT_TOOL_INTERACTIVE}_connectComputationToTarget(t){return nt([this._updatingHandles.add(()=>({computation:t,targetPosition:t.target.position,targetElevationInfo:t.target.elevationInfo,targetFeatureInfo:t.target.feature,projectedTargetPosition:ot(t.target.position,this.view.spatialReference)}),({computation:e,targetPosition:i,targetElevationInfo:s,targetFeatureInfo:r,projectedTargetPosition:l})=>{d(l.pending)?this._updatingHandles.addPromise(l.pending):this._onTargetPositionChange(e,i,l.geometry,s,r)},D)])}_connectComputationToObserver(t){return this._updatingHandles.add(()=>({computation:t,observer:this.analysisViewData.elevationAlignedObserver}),({computation:e})=>{this._externalObserverUpdate&&(e.inputPoints.isValid=!1,e.notifyInputPointsChanged())},D)}_connectComputationToRenderSpaceObserver(t){return this._updatingHandles.add(()=>({computation:t,observer:this._elevationAlignedObserverPositionRenderSpace,observerGroundOffset:this._observerGroundOffsetRenderSpace,observerElevationMode:this._effectiveObserverElevationMode,observerFeatureId:this._observerFeatureId}),({computation:e,observer:i,observerGroundOffset:s,observerElevationMode:r,observerFeatureId:l})=>{this._onObserverRenderSpacePositionChangeForComputation(e,i,s,r,l)},D)}_connectComputationToCamera(t){return this._updatingHandles.add(()=>({camera:this.view.state.camera,isDirty:this._isCameraDirty}),({isDirty:e})=>{!this.updateOnCameraChange||t.inputPoints.isValid&&!e||t.notifyInputPointsChanged()})}_connectComputationToSlicePlane(t){return this._updatingHandles.add(()=>this.view.slicePlane,()=>{t.inputPoints.isValid=!1,t.notifyInputPointsChanged()})}_connectComputationToElevation(t){const e=(i,s)=>{const r=this.analysis.observer,l=t.target;let a=null,v=null,g=null,p=null,c=null,y=null;if(d(r)&&d(r.position)){const m=ot(r.position,this.view.spatialReference);if(d(m.pending))return this._updatingHandles.addPromise(m.pending),void m.pending.finally(()=>e(i,s));a=m.geometry,v=r.elevationInfo,g=r.feature}if(d(l.position)){const m=ot(l.position,this.view.spatialReference);if(d(m.pending))return this._updatingHandles.addPromise(m.pending),void m.pending.finally(()=>e(i,s));p=m.geometry,c=l.elevationInfo,y=l.feature}h(a)&&h(p)||(te(i,s,rt,this.view.spatialReference),d(a)&&It(rt,a)&&this._onObserverPositionChange(d(r)?r.position:null,a,v,g,!1),d(p)&&It(rt,p)&&this._onTargetPositionChange(t,l.position,p,c,y,!1),d(a)&&d(p)&&ee(rt,a,p)&&t.notifyInputPointsChanged())};return this.view.elevationProvider.on("elevation-change",i=>e(i.extent,i.spatialReference))}_connectComputationToTask(t){let e=ie;const i={computation:t,interpolationInfo:{originalIntersection:_(),originalObserver:_(),originalTarget:_()}};return nt([this._updatingHandles.add(()=>t.inputPoints,()=>{e=Tt(e),e=Kt(async s=>{await Qt(this._frameTask.schedule(()=>this._computeResult(i),s))})},{initial:!0,equals:()=>!1}),zt(()=>e=Tt(e))])}_connectComputation(t){const e=this._computationHandles;e.has(t)||e.add([this._connectComputationToTarget(t),this._connectComputationToObserver(t),this._connectComputationToRenderSpaceObserver(t),this._connectComputationToCamera(t),this._connectComputationToSlicePlane(t),this._connectComputationToElevation(t),this._connectComputationToTask(t)],t)}_disconnectComputation(t){this._computationHandles.remove(t)}_onComputationCollectionChange({added:t,removed:e}){for(const i of e)this._disconnectComputation(i);for(const i of t)this._connectComputation(i)}_onTargetCollectionChange({added:t,removed:e}){for(const i of e)this._removeTarget(i);for(const i of t)this._addTarget(i)}_onCursorTargetChange(t,e){d(e)&&this._removeTarget(e),d(t)&&this._addTarget(t)}_addTarget(t){this._computations.some(e=>e.target===t)||this._computations.add(new G({target:t}))}_removeTarget(t){const e=this._computations.findIndex(i=>i.target===t);this._computations.removeAt(e)}_connectObserver(){return nt([this._updatingHandles.add(()=>({observerPosition:d(this.analysis.observer)?this.analysis.observer.position:null,projectedObserverPosition:ot(d(this.analysis.observer)?this.analysis.observer.position:null,this.view.spatialReference),observerElevationInfo:d(this.analysis.observer)?this.analysis.observer.elevationInfo:null,observerFeatureInfo:d(this.analysis.observer)?this.analysis.observer.feature:null}),({observerPosition:t,projectedObserverPosition:e,observerElevationInfo:i,observerFeatureInfo:s})=>{d(e.pending)?this._updatingHandles.addPromise(e.pending):this._onObserverPositionChange(t,e.geometry,i,s,!0)},D)])}_connectComputations(){return this._updatingHandles.addOnCollectionChange(()=>this._computations,t=>this._onComputationCollectionChange(t),{initial:!0,final:!0})}_connectTargets(){return nt([this._updatingHandles.addOnCollectionChange(()=>this.analysis.targets,t=>this._onTargetCollectionChange(t),{initial:!0,final:!0}),this._updatingHandles.add(()=>this.analysisViewData.cursorTarget,(t,e)=>{this._onCursorTargetChange(t,e)})])}get _isCameraDirty(){const t=this.analysisViewData.elevationAlignedObserver,{view:e}=this,{renderCoordsHelper:i}=e;if(h(t)||h(i))return!1;const s=st;i.toRenderCoords(t,s);const r=e.state.camera.computeScreenPixelSizeAt(s);return Math.abs((r-this._screenPixelSize)/this._screenPixelSize)>$e}_getEffectiveElevationInfo(t,e){return t.hasZ?Xt(e,{mode:"absolute-height",offset:0}):{mode:"on-the-ground",offset:0}}};n([o({constructOnly:!0})],f.prototype,"analysis",void 0),n([o({constructOnly:!0})],f.prototype,"analysisViewData",void 0),n([o({constructOnly:!0})],f.prototype,"view",void 0),n([o()],f.prototype,"updating",null),n([o()],f.prototype,"priority",null),n([o()],f.prototype,"updateOnCameraChange",void 0),n([o()],f.prototype,"_computations",null),n([o()],f.prototype,"_elevationAlignedObserverPositionRenderSpace",null),n([o()],f.prototype,"_observerGroundOffsetRenderSpace",void 0),n([o()],f.prototype,"_effectiveObserverElevationMode",void 0),n([o()],f.prototype,"_observerFeatureId",void 0),n([o()],f.prototype,"_screenPixelSize",null),n([o({readOnly:!0})],f.prototype,"_updatingHandles",void 0),n([o()],f.prototype,"_frameTask",void 0),n([o()],f.prototype,"_isCameraDirty",null),f=n([V(Gt)],f);const $e=.1,st=_(),Mt=Ft(),rt=Yt(),He=.05;let H=class extends L{constructor(t){super(t),this.enabled=!0,this.glowColor=new u([255,127,0]),this.glowWidth=8,this.innerColor=new u([255,255,255]),this.innerWidth=.75,this.globalAlpha=.75}};n([o({type:Boolean})],H.prototype,"enabled",void 0),n([o({type:u})],H.prototype,"glowColor",void 0),n([o({type:Number})],H.prototype,"glowWidth",void 0),n([o({type:u})],H.prototype,"innerColor",void 0),n([o({type:Number})],H.prototype,"innerWidth",void 0),n([o({type:Number})],H.prototype,"globalAlpha",void 0),H=n([V("esri.views.3d.interactive.analysisTools.lineOfSight.LineOfSightLaserLineConfiguration")],H);let Z=class extends L{constructor(e){super(e),this.size=.5,this.color=new u([255,127,0,.75])}};n([o({type:Number})],Z.prototype,"size",void 0),n([o({type:u})],Z.prototype,"color",void 0),Z=n([V("esri.views.3d.interactive.analysisTools.lineOfSight.LineOfSightObserverConfiguration")],Z);let N=class extends L{constructor(t){super(t),this.size=.5,this.visibleColor=new u([3,252,111,.75]),this.occludedColor=new u([252,3,69,.75]),this.undefinedColor=new u([127,127,127,.75])}};n([o({type:Number})],N.prototype,"size",void 0),n([o({type:u})],N.prototype,"visibleColor",void 0),n([o({type:u})],N.prototype,"occludedColor",void 0),n([o({type:u})],N.prototype,"undefinedColor",void 0),N=n([V("esri.views.3d.interactive.analysisTools.lineOfSight.LineOfSightTargetConfiguration")],N);class M extends L{constructor(e){super(e),this.innerWidth=2,this.outerWidth=8,this.visibleInnerColor=new u([3,252,111,1]),this.visibleOuterColor=new u([3,252,111,.15]),this.occludedInnerColor=new u([252,3,69,1]),this.occludedOuterColor=new u([252,3,69,.1]),this.undefinedInnerColor=new u([255,255,255,1]),this.undefinedOuterColor=new u([127,127,127,.2])}}n([o({type:Number})],M.prototype,"innerWidth",void 0),n([o({type:Number})],M.prototype,"outerWidth",void 0),n([o({type:u})],M.prototype,"visibleInnerColor",void 0),n([o({type:u})],M.prototype,"visibleOuterColor",void 0),n([o({type:u})],M.prototype,"occludedInnerColor",void 0),n([o({type:u})],M.prototype,"occludedOuterColor",void 0),n([o({type:u})],M.prototype,"undefinedInnerColor",void 0),n([o({type:u})],M.prototype,"undefinedOuterColor",void 0);let j=class extends L{constructor(t){super(t),this.laserLine=new H,this.observer=new Z,this.target=new N,this.lineOfSight=new M}};n([o({type:H})],j.prototype,"laserLine",void 0),n([o({type:Z})],j.prototype,"observer",void 0),n([o({type:N})],j.prototype,"target",void 0),n([o({type:M})],j.prototype,"lineOfSight",void 0),j=n([V("esri.views.3d.interactive.analysisTools.lineOfSight.LineOfSightToolConfiguration")],j);function Me(t,e){let i=null;const s=t.events.on("grab-changed",r=>{d(i)&&(i.remove(),i=null),r.action==="start"&&(i=t.disableDisplay()),e&&e(r)});return{remove(){d(i)&&i.remove(),s.remove()}}}function at(t,e,i){return new we(_e(Oe(u.toUnitRGBA(e)),t,32,32),i)}function Nt(t){const e=[];return t.customColor1&&e.push(at(t.size,t.customColor1,Q.Custom1)),t.customColor2&&e.push(at(t.size,t.customColor2,Q.Custom2)),t.customColor3&&e.push(at(t.size,t.customColor3,Q.Custom3)),t.color&&e.push(at(t.size,t.color)),e}function De(t,e){const i=Nt(e),s=new Ce({view:t,renderObjects:i,elevationInfo:{mode:"absolute-height",offset:0}});return Me(s),s}var U;(function(t){t.Ready="ready",t.Creating="creating",t.Created="created"})(U||(U={}));let O=class extends Te{constructor(t){super(t),this.removeIncompleteOnCancel=!1,this.configuration=new j,this.analysisViewData=null,this._latestPointerMovePointerType=null,this._laserlineVisualElement=null,this._grabbedManipulator=null,this._analysisHandles=new K,this._handles=new K,this._updatingHandles=new Ct,this._manipulatorHandles=new K,this._targetTrackerManipulator=null}initialize(){this._intersector=new q({view:this.view}),this._handles.add(ne(()=>this.state,t=>{t===U.Created&&this.finishToolCreation()},oe)),this._observerManipulator=this._createObserverManipulator(),this._handles.add([this._updatingHandles.add(()=>({...this.configuration.observer}),()=>this._updateObserverManipulatorStyle()),this._updatingHandles.add(()=>{var t;return(t=this.analysisViewData)==null?void 0:t.elevationAlignedObserver},t=>this._onObserverLocationChange(t),D),this._updatingHandles.add(()=>({...this.configuration.laserLine}),()=>this._createVisualElements(),D),this._updatingHandles.add(()=>this._laserLineRendererDependencies(),t=>this._updateLaserLineRenderer(t)),this._connectComputations(),this._updatingHandles.addWhen(()=>!this._shouldRenderTracker,()=>this._clearCursorTracker(),D)])}destroy(){this._updatingHandles=k(this._updatingHandles),this._handles=k(this._handles),this._manipulatorHandles=k(this._manipulatorHandles),this._analysisHandles=k(this._analysisHandles),this._observerManipulator=null,this._clearCursorTracker(),this._removeVisualElements(),this._intersector=null,this._set("analysis",null)}get state(){return this.active?this.hasGrabbedManipulators?U.Created:U.Creating:d(this.analysis.observer)&&d(this.analysis.observer.position)?U.Created:U.Ready}get cursor(){return this.active&&this._showTracker?"crosshair":null}get updating(){return d(this.analysisViewData)&&this.analysisViewData.updating||this._updatingHandles.updating}get _showTracker(){return this.active&&this._latestPointerMovePointerType==="mouse"}get _shouldRenderTracker(){return this._showTracker&&d(this.analysis.observer)&&d(this.analysis.observer.position)&&!this.hasGrabbedManipulators}continue(){this.view.activeTool=this}stop(){this.view.activeTool=null}onEditableChange(){this.analysisViewData.editable=this.internallyEditable}onInputEvent(t){switch(t.type){case"immediate-double-click":this._doubleClickHandler(t);break;case"key-down":this._keyDownHandler(t);break;case"pointer-move":this._pointerMoveHandler(t)}}onInputEventAfter(t){t.type==="immediate-click"&&this._clickHandler(t)}onShow(){}onHide(){}onDeactivate(){this._clearCursorTracker()}_connectComputations(){return this._updatingHandles.addOnCollectionChange(()=>this.analysisViewData.computations,t=>this._onComputationsCollectionChange(t),{initial:!0,final:!0})}_onComputationsCollectionChange({added:t,removed:e}){for(const i of e)this._disconnectComputation(i);for(const i of t)this._connectComputation(i)}_connectComputation(t){if(this.destroyed)return void _t.getLogger(this.declaredClass).warn("Attempting to connect an analysis to a destroyed LineOfSight tool. Ignoring.");const e=this._analysisHandles;if(e.has(t))return;const i=this._createTargetManipulator(t.target);h(this._targetTrackerManipulator)&&i.metadata.target===this.analysisViewData.cursorTarget&&(this._targetTrackerManipulator=i,this._targetTrackerManipulator.available=!1,this._targetTrackerManipulator.interactive=!1,this._updateLaserLineRenderer()),e.add([this._updatingHandles.add(()=>this._getLineOfSightManipulatorStateDependencies(t),()=>this._updateManipulatorState(i,t),D),this._updatingHandles.add(()=>t.elevationAlignedTargetLocation,s=>this._onTargetLocationChange(s,i),D)],t)}_disconnectComputation(t){if(this.destroyed)return void _t.getLogger(this.declaredClass).warn("Attempting to disconnect an analysis from a destroyed LineOfSight tool. Ignoring.");this._analysisHandles.remove(t);const e=this._getTargetManipulator(t.target);d(e)&&(this.manipulators.remove(e),this._manipulatorHandles.remove(e),d(this._targetTrackerManipulator)&&this._targetTrackerManipulator===e&&(this._targetTrackerManipulator=null))}_clearCursorTracker(){this.analysisViewData.cursorTarget=k(this.analysisViewData.cursorTarget)}_createManipulator(t,e,i){const s=De(this.view,t);return s.metadata=i,this._manipulatorHandles.add([e(s),s.events.on("grab-changed",r=>this._manipulatorGrabChanged(s,r)),s.events.on("immediate-click",r=>this._manipulatorClick(s,r))],s),this.manipulators.add(s),s}_createTargetManipulator(t){const e=this.configuration,i={size:e.target.size,customColor1:e.target.visibleColor,customColor2:e.target.occludedColor,customColor3:e.target.undefinedColor,visible:!0},s={target:t,type:"target"},r=this._createManipulator(i,l=>this._createTargetManipulatorDragPipeline(l),s);return d(t.position)?r.elevationAlignedLocation=t.position:r.available=!1,r}_getTargetManipulator(t){let e=null;return this.manipulators.forEach(i=>{const s=i.manipulator;h(e)&&s.metadata.type==="target"&&s.metadata.target===t&&(e=s)}),e}_createObserverManipulator(){const t=this.configuration,e={size:t.observer.size,color:t.observer.color,visible:!0};return this._createManipulator(e,i=>this._createObserverManipulatorDragPipeline(i),{type:"observer",intersection:null})}_updateObserverManipulatorStyle(){const t=this._observerManipulator,e=this.configuration.observer,i={size:e.size,color:e.color,visible:t.available};t.renderObjects=Nt(i)}_screenToIntersection(){return t=>{const e=this._intersector.getScreenPointIntersection(t.screenEnd);return h(e)?null:{...t,intersection:e}}}_createTargetManipulatorDragPipeline(t){return At(t,(e,i,s)=>{i.next(this._screenToIntersection()).next(this._updateTargetDragStep(t)).next(()=>this._updateLaserLineRenderer()),s.next(this._cancelTargetDragStep(t.metadata.target)).next(()=>this._updateLaserLineRenderer())})}_createObserverManipulatorDragPipeline(t){return At(t,(e,i,s)=>{i.next(this._screenToIntersection()).next(this._updateObserverDragStep()).next(()=>this._updateLaserLineRenderer()),s.next(this._cancelObserverDragStep()).next(()=>this._updateLaserLineRenderer())})}_updateObserverDragStep(){return t=>(d(t.intersection.mapPoint)?(h(this.analysis.observer)&&(this.analysis.observer=new St),this._updateFromIntersection(this.analysis.observer,t.intersection)):this.analysis.observer=null,t)}_cancelObserverDragStep(){const t=d(this.analysis.observer)&&d(this.analysis.observer.position)?this.analysis.observer.clone():null;return e=>(this.analysis.observer=t,e)}_updateTargetDragStep(t){return e=>{this._updateFromIntersection(t.metadata.target,e.intersection);const i=e.intersection.mapPoint;return d(i)&&(t.elevationAlignedLocation=i),e}}_cancelTargetDragStep(t){const e=xt(t.position,i=>i.clone());return i=>(t.position=e,i)}_manipulatorGrabChanged(t,e){switch(e.action){case"start":this._grabbedManipulator=t;break;case"end":this._grabbedManipulator===t&&(this._grabbedManipulator=null)}}_updateManipulatorState(t,e){const{isValid:i,isTargetVisible:s}=e.computationResult;t.state=i?s?Q.Custom1:Q.Custom2:Q.Custom3}_getLineOfSightManipulatorStateDependencies(t){const{isValid:e,isTargetVisible:i}=t.computationResult;return{isValid:e,isTargetVisible:i}}_laserLineRendererDependencies(){return{laserlineVisualElement:this._laserlineVisualElement,grabbedManipulator:this._grabbedManipulator,shouldRenderTracker:this._shouldRenderTracker,observerPosition:d(this.analysis.observer)?this.analysis.observer.position:null,visible:this.visible}}_updateLaserLineRenderer(t=this._laserLineRendererDependencies()){const{laserlineVisualElement:e,grabbedManipulator:i,shouldRenderTracker:s,observerPosition:r,visible:l}=t;if(h(e))return;const a=d(i)?i:s&&d(r)?this._targetTrackerManipulator:null;this.configuration.laserLine.enabled&&d(a)&&l?(e.visible=!0,e.heightManifoldTarget=a.renderLocation,a!==this._observerManipulator?e.lineVerticalPlaneSegment=fe(this._observerManipulator.renderLocation,a.renderLocation,ke):e.lineVerticalPlaneSegment=null):(e.visible=!1,e.heightManifoldTarget=null,e.lineVerticalPlaneSegment=null)}_createVisualElements(){const t=this.configuration.laserLine;this._removeVisualElements(),this._laserlineVisualElement=new Ve({view:this.view,attached:!0,visible:this.visible,style:{glowColor:u.toUnitRGB(t.glowColor),glowWidth:t.glowWidth,innerColor:u.toUnitRGB(t.innerColor),innerWidth:t.innerWidth,globalAlpha:t.globalAlpha}})}_removeVisualElements(){d(this._laserlineVisualElement)&&(this._laserlineVisualElement.destroy(),this._laserlineVisualElement=null)}_onObserverLocationChange(t){h(t)?this._observerManipulator.available=!1:(this._observerManipulator.metadata.intersection=null,this._observerManipulator.available=!0,this._observerManipulator.elevationAlignedLocation=t)}_onTargetLocationChange(t,e){d(t)?(e.elevationAlignedLocation=t,e!==this._targetTrackerManipulator&&(e.available=!0)):e.available=!1}_addPointFromClickEvent(t){const e=this._intersector.getScreenPointIntersection(t);if(!h(e)&&!h(e.mapPoint))if(d(this.analysis.observer)&&d(this.analysis.observer.position)){this._clearCursorTracker();const i=new Rt;this._updateFromIntersection(i,e),this.analysis.targets.add(i)}else{const i=new St;this._updateFromIntersection(i,e),this.analysis.observer=i}}_clickHandler(t){this.active&&t.button!==ut.Right&&(this._addPointFromClickEvent(Pt(t)),t.stopPropagation())}_doubleClickHandler(t){this.active&&t.button!==ut.Right&&(this.stop(),t.stopPropagation())}_keyDownHandler(t){this.active&&t.key==="Escape"&&(this.stop(),t.stopPropagation())}_pointerMoveHandler(t){if(this.hasGrabbedManipulators||(this._latestPointerMovePointerType=t.pointerType,this._updateLaserLineRenderer(),!this._showTracker||h(this.analysis.observer)||h(this.analysis.observer.position)))return;const e=Pt(t),i=this._intersector.getScreenPointIntersection(e);d(i)&&d(i.mapPoint)&&(h(this.analysisViewData.cursorTarget)&&(this.analysisViewData.cursorTarget=new Rt),this._updateFromIntersection(this.analysisViewData.cursorTarget,i),this._updateLaserLineRenderer())}_updateFromIntersection(t,e){if(h(e.mapPoint))return t.position=null,t.elevationInfo=null,void(t.feature=null);switch(e.type){case X.OBJECT:if(d(e.graphic)){const s=e.graphic,r=de(s);r.mode==="on-the-ground"&&(r.mode="relative-to-ground",r.offset=0),t.elevationInfo=new Vt(r),t.feature=s}else t.elevationInfo=null,t.feature=null;break;case X.TERRAIN:case X.I3S:t.elevationInfo=new Vt({mode:"on-the-ground"}),t.feature=null;break;default:t.elevationInfo=null,t.feature=null}const i=e.mapPoint.clone();i.z=ue(this.view,i,{mode:"absolute-height",offset:0},t.elevationInfo),t.position=i}_manipulatorClick(t,e){if(t.metadata.type==="observer"||t.grabbing||t.dragging||e.button!==ut.Right||this.analysis.targets.length<=1)return;const{target:i}=t.metadata;this.analysis.targets.remove(i),e.stopPropagation()}get testInfo(){return{laserLineVisualElement:this._laserlineVisualElement}}};n([o({constructOnly:!0})],O.prototype,"view",void 0),n([o({constructOnly:!0})],O.prototype,"analysis",void 0),n([o({readOnly:!0})],O.prototype,"state",null),n([o({readOnly:!0})],O.prototype,"cursor",null),n([o()],O.prototype,"removeIncompleteOnCancel",void 0),n([o({readOnly:!0})],O.prototype,"updating",null),n([o({type:j})],O.prototype,"configuration",void 0),n([o({constructOnly:!0})],O.prototype,"analysisViewData",void 0),n([o({readOnly:!0})],O.prototype,"_showTracker",null),n([o()],O.prototype,"_latestPointerMovePointerType",void 0),n([o()],O.prototype,"_shouldRenderTracker",null),n([o()],O.prototype,"_laserlineVisualElement",void 0),n([o()],O.prototype,"_grabbedManipulator",void 0),O=n([V("esri.views.3d.interactive.analysisTools.lineOfSight.LineOfSightTool")],O);const ke=be();class ze{constructor(e,i,s,r){this.visibleLineVisualElement=e,this.occludedLineVisualElement=i,this.undefinedLineVisualElement=s,this.targetVisualElement=r}destroy(){this.visibleLineVisualElement.destroy(),this.occludedLineVisualElement.destroy(),this.undefinedLineVisualElement.destroy(),this.targetVisualElement.destroy()}}let $=class extends L{constructor(t){super(t),this._lineOfSightVisualElements=new Array,this._computationHandles=new K,this._updatingHandles=new Ct}initialize(){this.addHandles(this._connectComputations()),this._createObserverVisualization()}destroy(){this._updatingHandles=k(this._updatingHandles),this._computationHandles=k(this._computationHandles),this._observerVisualElement=k(this._observerVisualElement)}get visible(){return this.analysisViewData.visible}get updating(){return this._updatingHandles.updating}get interactiveAndEditable(){return this.analysisViewData.interactive&&this.analysisViewData.editable}get test(){return{disablePartialOcclusion:()=>{for(const t of this._lineOfSightVisualElements)t.visibleLineVisualElement.renderOccluded=gt.Occlude,t.occludedLineVisualElement.renderOccluded=gt.Occlude,t.undefinedLineVisualElement.renderOccluded=gt.Occlude},visualizations:this._lineOfSightVisualElements}}get _configuration(){return this.analysisViewData.configuration}_createLineOfSightVisualization(){const t=this._configuration,e=this.view,i={view:e,attached:!0,width:t.outerWidth,innerWidth:t.innerWidth},s=u.toUnitRGBA(t.visibleOuterColor),r=u.toUnitRGBA(t.visibleInnerColor),l=u.toUnitRGBA(t.occludedOuterColor),a=u.toUnitRGBA(t.occludedInnerColor),v=u.toUnitRGBA(t.undefinedOuterColor),g=u.toUnitRGBA(t.undefinedInnerColor),p=new ct({...i,color:s,innerColor:r}),c=new ct({...i,color:l,innerColor:a}),y=new ct({...i,color:v,innerColor:g}),m=new $t({view:e,attached:!0,...Dt,size:8}),w=new ze(p,c,y,m);return this._lineOfSightVisualElements.push(w),w}_destroyLineOfSightVisualization(t){t.destroy(),this._lineOfSightVisualElements.splice(this._lineOfSightVisualElements.indexOf(t),1)}_updateLineOfSightVisualization(t,e,i){const s=this._configuration,{computationResult:r,inputPoints:l}=t,{start:a,end:v,intersection:g,isValid:p,isTargetVisible:c}=r,{observer:y}=l,m=Ne;m[12]=y[0],m[13]=y[1],m[14]=y[2];const w=tt(xe,a,y),I=tt(Fe,v,y),T=tt(Ge,g,y),{visibleLineVisualElement:b,occludedLineVisualElement:E,undefinedLineVisualElement:S,targetVisualElement:z}=e,jt=h(this.analysisViewData.elevationAlignedObserver)||h(t.elevationAlignedTargetLocation),Y=this.visible&&!jt;b.visible=Y,E.visible=Y,S.visible=Y,z.visible=Y,z.attached=!i.interactiveAndEditable,Y&&(b.geometry=null,E.geometry=null,S.geometry=null,z.geometry=t.elevationAlignedTargetLocation,p?c?(b.geometry=[[x(w),x(I)]],b.transform=m,b.color=u.toUnitRGBA(s.visibleOuterColor),z.color=u.toUnitRGBA(s.visibleInnerColor)):(b.geometry=[[x(w),x(T)]],b.transform=m,b.color=u.toUnitRGBA(s.occludedOuterColor),E.geometry=[[x(T),x(I)]],E.transform=m,z.color=u.toUnitRGBA(s.occludedInnerColor)):(S.geometry=[[x(w),x(I)]],S.transform=m,z.color=u.toUnitRGBA(s.undefinedInnerColor)))}_getLineOfSightVisualizationDependencies(t){const{computationResult:e}=t,{occludedOuterColor:i,visibleOuterColor:s}=this._configuration;return{computationResult:e,occludedOuterColor:i,visibleOuterColor:s,visible:this.visible,interactiveAndEditable:this.interactiveAndEditable}}_connectComputation(t){const e=this._computationHandles;if(e.has(t))return;const i=this._createLineOfSightVisualization();e.add([this._updatingHandles.add(()=>this._getLineOfSightVisualizationDependencies(t),s=>this._updateLineOfSightVisualization(t,i,s),{initial:!0,equals:()=>!1}),zt(()=>this._destroyLineOfSightVisualization(i))],t)}_disconnectComputation(t){this._computationHandles.remove(t)}_connectComputations(){return this._updatingHandles.addOnCollectionChange(()=>this.analysisViewData.computations,t=>this._onComputationsCollectionChange(t),{initial:!0,final:!0})}_onComputationsCollectionChange({added:t,removed:e}){for(const i of e)this._disconnectComputation(i);for(const i of t)this._connectComputation(i)}_createObserverVisualization(){const t=u.toUnitRGBA(this._configuration.visibleInnerColor),e=new $t({view:this.view,attached:!1,color:t,...Dt});this._observerVisualElement=e,this.addHandles(this._updatingHandles.add(()=>({observer:this.analysisViewData.elevationAlignedObserver,interactiveAndEditable:this.interactiveAndEditable,visible:this.visible}),({observer:i,interactiveAndEditable:s,visible:r})=>{h(i)||s||!r?e.attached=!1:(e.geometry=i,this._observerVisualElement.attached=!0)},D))}};n([o({constructOnly:!0})],$.prototype,"analysis",void 0),n([o({constructOnly:!0})],$.prototype,"analysisViewData",void 0),n([o({constructOnly:!0})],$.prototype,"view",void 0),n([o({readOnly:!0})],$.prototype,"visible",null),n([o()],$.prototype,"updating",null),n([o()],$.prototype,"interactiveAndEditable",null),n([o()],$.prototype,"test",null),n([o()],$.prototype,"_configuration",null),$=n([V("esri.views.3d.analysis.LineOfSight.LineOfSightVisualization")],$);const Dt={size:6,pixelSnappingEnabled:!1,primitive:"circle",elevationInfo:{mode:"absolute-height",offset:0},outlineSize:0},xe=_(),Fe=_(),Ge=_(),Ne=Le();let C=class extends re(kt.EventedMixin(L)){constructor(t){super(t),this.type="line-of-sight-view-3d",this.analysis=null,this.tool=null,this.computations=new se,this.elevationAlignedObserver=null,this.configuration=new A,this.observerEngineLocation=_(),this.cursorTarget=null,this.editable=!0}initialize(){const t=this.view,e=this.analysis;this._analysisController=new f({analysis:e,analysisViewData:this,view:t}),this._analysisVisualization=new $({analysis:e,analysisViewData:this,view:t}),this.addHandles([this._analysisController.on("result-changed",i=>{i.target!==this.cursorTarget&&this.emit("result-changed",i)}),Ie(this,O)])}destroy(){Pe(this),this._analysisController=k(this._analysisController),this._analysisVisualization=k(this._analysisVisualization)}get results(){return this.computations.map(t=>t.result)}get priority(){return this._analysisController.priority}set priority(t){this._analysisController.priority=t}get updating(){return d(this._analysisController)&&this._analysisController.updating||d(this._analysisVisualization)&&this._analysisVisualization.updating}getResultForTarget(t){const e=this.computations.find(i=>i.target===t);return xt(e,i=>i.result)}get testInfo(){return{visualization:this._analysisVisualization,controller:this._analysisController}}};n([o({readOnly:!0})],C.prototype,"type",void 0),n([o({constructOnly:!0,nonNullable:!0})],C.prototype,"analysis",void 0),n([o()],C.prototype,"tool",void 0),n([o({readOnly:!0})],C.prototype,"results",null),n([o()],C.prototype,"priority",null),n([o()],C.prototype,"computations",void 0),n([o()],C.prototype,"elevationAlignedObserver",void 0),n([o()],C.prototype,"configuration",void 0),n([o()],C.prototype,"observerEngineLocation",void 0),n([o()],C.prototype,"cursorTarget",void 0),n([o()],C.prototype,"updating",null),n([o()],C.prototype,"editable",void 0),n([o()],C.prototype,"_analysisController",void 0),n([o()],C.prototype,"_analysisVisualization",void 0),C=n([V("esri.views.3d.analysis.LineOfSightAnalysisView3D")],C);const Rn=C;export{Rn as default};
