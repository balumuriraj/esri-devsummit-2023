import{R as u,a3 as m,$ as D,h3 as P,gW as j,gV as F,f2 as k,f8 as O}from"./calcite-8912bd40.js";import{E as p}from"./enums-fb086c25.js";import{E as d,f as g}from"./FramebufferObject-8b18fc0c.js";import{F as x}from"./enums-e2e92c86.js";import{e as _}from"./config-1337d16e.js";import{r as E}from"./TiledDisplayObject-419c008b.js";class z{constructor(e){this.xTile=0,this.yTile=0,this.hash=0,this.priority=1,this.colliders=[],this.textVertexRanges=[],this.iconVertexRanges=[],this.tile=e}}let Z=class{constructor(){this.tileSymbols=[],this.parts=[{startTime:0,startOpacity:0,targetOpacity:0,show:!1},{startTime:0,startOpacity:0,targetOpacity:0,show:!1}],this.show=!1}};function et(l,e,r,t,s,a){const i=r-s;if(i>=0)return(e>>i)+(t-(a<<i))*(l>>i);const n=-i;return e-(a-(t<<n))*(l>>n)<<n}let st=class{constructor(e,r,t){this._rows=Math.ceil(r/t),this._columns=Math.ceil(e/t),this._cellSize=t,this.cells=new Array(this._rows);for(let s=0;s<this._rows;s++){this.cells[s]=new Array(this._columns);for(let a=0;a<this._columns;a++)this.cells[s][a]=[]}}getCell(e,r){const t=Math.min(Math.max(Math.floor(r/this._cellSize),0),this._rows-1),s=Math.min(Math.max(Math.floor(e/this._cellSize),0),this._columns-1);return this.cells[t]&&this.cells[t][s]||null}getCellSpan(e,r,t,s){return[Math.min(Math.max(Math.floor(e/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(r/this._cellSize),0),this.rows-1),Math.min(Math.max(Math.floor(t/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(s/this._cellSize),0),this.rows-1)]}get cellSize(){return this._cellSize}get columns(){return this._columns}get rows(){return this._rows}};function W(l,e,r,t,s,a){const i=e[t++];for(let n=0;n<i;n++){const o=new z(a);o.xTile=e[t++],o.yTile=e[t++],o.hash=e[t++],o.priority=e[t++];const c=e[t++];for(let h=0;h<c;h++){const I=e[t++],B=e[t++],b=e[t++],S=e[t++],C=!!e[t++],M=e[t++],U=r[t++],L=r[t++],R=e[t++],T=e[t++];o.colliders.push({xTile:I,yTile:B,dxPixels:b,dyPixels:S,hard:C,partIndex:M,width:R,height:T,minLod:U,maxLod:L})}const y=l[t++];for(let h=0;h<y;h++)o.textVertexRanges.push([l[t++],l[t++]]);const f=l[t++];for(let h=0;h<f;h++)o.iconVertexRanges.push([l[t++],l[t++]]);s.push(o)}return t}function it(l,e,r){for(const[t,s]of l.symbols)$(l,e,r,s,t)}function $(l,e,r,t,s){const a=l.layerData.get(s);if(a.type===p.SYMBOL){for(const i of t){const n=i.unique;let o;if(i.selectedForRendering){const c=n.parts[0],y=c.startOpacity,f=c.targetOpacity;l.allSymbolsFadingOut=l.allSymbolsFadingOut&&f===0;const h=r?Math.floor(127*y)|f<<7:f?255:0;o=h<<24|h<<16|h<<8|h}else o=0;for(const[c,y]of i.iconVertexRanges)for(let f=c;f<c+y;f+=4)a.iconOpacity[f/4]=o;if(i.selectedForRendering){const c=n.parts[1],y=c.startOpacity,f=c.targetOpacity;l.allSymbolsFadingOut=l.allSymbolsFadingOut&&f===0;const h=r?Math.floor(127*y)|f<<7:f?255:0;o=h<<24|h<<16|h<<8|h}else o=0;for(const[c,y]of i.textVertexRanges)for(let f=c;f<c+y;f+=4)a.textOpacity[f/4]=o}a.lastOpacityUpdate=e,a.opacityChanged=!0}}class A{constructor(e,r){this.layerUIDs=[],this.isDestroyed=!1,this._data=e,this.memoryUsed=e.byteLength;let t=1;const s=new Uint32Array(e);this.layerUIDs=[];const a=s[t++];for(let i=0;i<a;i++)this.layerUIDs[i]=s[t++];this.bufferDataOffset=t,r&&(this.layer=r.getStyleLayerByUID(this.layerUIDs[0]))}get isPreparedForRendering(){return D(this._data)}get offset(){return this.bufferDataOffset}destroy(){this.isDestroyed||(this.doDestroy(),this.isDestroyed=!0)}prepareForRendering(e){D(this._data)||(this.doPrepareForRendering(e,this._data,this.bufferDataOffset),this._data=null)}}class Y extends A{constructor(e,r){super(e,r),this.type=p.LINE,this.lineIndexStart=0,this.lineIndexCount=0;const t=new Uint32Array(e);let s=this.bufferDataOffset;this.lineIndexStart=t[s++],this.lineIndexCount=t[s++];const a=t[s++];if(a>0){const i=new Map;for(let n=0;n<a;n++){const o=t[s++],c=t[s++],y=t[s++];i.set(o,[c,y])}this.patternMap=i}this.bufferDataOffset=s}hasData(){return this.lineIndexCount>0}triangleCount(){return this.lineIndexCount/3}doDestroy(){u(this.lineVertexArrayObject)&&this.lineVertexArrayObject.dispose(),u(this.lineVertexBuffer)&&this.lineVertexBuffer.dispose(),u(this.lineIndexBuffer)&&this.lineIndexBuffer.dispose(),this.lineVertexArrayObject=null,this.lineVertexBuffer=null,this.lineIndexBuffer=null,this.memoryUsed=0}doPrepareForRendering(e,r,t){const s=new Uint32Array(r),a=new Int32Array(s.buffer),i=s[t++];this.lineVertexBuffer=d.createVertex(e,x.STATIC_DRAW,new Int32Array(a.buffer,4*t,i)),t+=i;const n=s[t++];this.lineIndexBuffer=d.createIndex(e,x.STATIC_DRAW,new Uint32Array(s.buffer,4*t,n)),t+=n;const o=this.layer.lineMaterial;this.lineVertexArrayObject=new g(e,o.getAttributeLocations(),o.getLayoutInfo(),{geometry:this.lineVertexBuffer},this.lineIndexBuffer)}}let v=class extends A{constructor(e,r){super(e,r),this.type=p.FILL,this.fillIndexStart=0,this.fillIndexCount=0,this.outlineIndexStart=0,this.outlineIndexCount=0;const t=new Uint32Array(e);let s=this.bufferDataOffset;this.fillIndexStart=t[s++],this.fillIndexCount=t[s++],this.outlineIndexStart=t[s++],this.outlineIndexCount=t[s++];const a=t[s++];if(a>0){const i=new Map;for(let n=0;n<a;n++){const o=t[s++],c=t[s++],y=t[s++];i.set(o,[c,y])}this.patternMap=i}this.bufferDataOffset=s}hasData(){return this.fillIndexCount>0||this.outlineIndexCount>0}triangleCount(){return(this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){u(this.fillVertexArrayObject)&&this.fillVertexArrayObject.dispose(),u(this.fillVertexBuffer)&&this.fillVertexBuffer.dispose(),u(this.fillIndexBuffer)&&this.fillIndexBuffer.dispose(),this.fillVertexArrayObject=null,this.fillVertexBuffer=null,this.fillIndexBuffer=null,u(this.outlineVertexArrayObject)&&this.outlineVertexArrayObject.dispose(),u(this.outlineVertexBuffer)&&this.outlineVertexBuffer.dispose(),u(this.outlineIndexBuffer)&&this.outlineIndexBuffer.dispose(),this.outlineVertexArrayObject=null,this.outlineVertexBuffer=null,this.outlineIndexBuffer=null,this.memoryUsed=0}doPrepareForRendering(e,r,t){const s=new Uint32Array(r),a=new Int32Array(s.buffer),i=s[t++];this.fillVertexBuffer=d.createVertex(e,x.STATIC_DRAW,new Int32Array(a.buffer,4*t,i)),t+=i;const n=s[t++];this.fillIndexBuffer=d.createIndex(e,x.STATIC_DRAW,new Uint32Array(s.buffer,4*t,n)),t+=n;const o=s[t++];this.outlineVertexBuffer=d.createVertex(e,x.STATIC_DRAW,new Int32Array(a.buffer,4*t,o)),t+=o;const c=s[t++];this.outlineIndexBuffer=d.createIndex(e,x.STATIC_DRAW,new Uint32Array(s.buffer,4*t,c)),t+=c;const y=this.layer,f=y.fillMaterial,h=y.outlineMaterial;this.fillVertexArrayObject=new g(e,f.getAttributeLocations(),f.getLayoutInfo(),{geometry:this.fillVertexBuffer},this.fillIndexBuffer),this.outlineVertexArrayObject=new g(e,h.getAttributeLocations(),h.getLayoutInfo(),{geometry:this.outlineVertexBuffer},this.outlineIndexBuffer)}};class q extends A{constructor(e,r,t){super(e,r),this.type=p.SYMBOL,this.iconPerPageElementsMap=new Map,this.glyphPerPageElementsMap=new Map,this.symbolInstances=[],this.isIconSDF=!1,this.opacityChanged=!1,this.lastOpacityUpdate=0,this.symbols=[];const s=new Uint32Array(e),a=new Int32Array(e),i=new Float32Array(e);let n=this.bufferDataOffset;this.isIconSDF=!!s[n++];const o=s[n++];for(let h=0;h<o;h++){const I=s[n++],B=s[n++],b=s[n++];this.iconPerPageElementsMap.set(I,[B,b])}const c=s[n++];for(let h=0;h<c;h++){const I=s[n++],B=s[n++],b=s[n++];this.glyphPerPageElementsMap.set(I,[B,b])}const y=s[n++],f=s[n++];this.iconOpacity=new Int32Array(y),this.textOpacity=new Int32Array(f),n=W(s,a,i,n,this.symbols,t),this.bufferDataOffset=n}hasData(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0}triangleCount(){let e=0;for(const[r,t]of this.iconPerPageElementsMap)e+=t[1];for(const[r,t]of this.glyphPerPageElementsMap)e+=t[1];return e/3}doDestroy(){u(this.iconVertexArrayObject)&&this.iconVertexArrayObject.dispose(),u(this.iconVertexBuffer)&&this.iconVertexBuffer.dispose(),u(this.iconOpacityBuffer)&&this.iconOpacityBuffer.dispose(),u(this.iconIndexBuffer)&&this.iconIndexBuffer.dispose(),this.iconVertexArrayObject=null,this.iconVertexBuffer=null,this.iconOpacityBuffer=null,this.iconIndexBuffer=null,u(this.textVertexArrayObject)&&this.textVertexArrayObject.dispose(),u(this.textVertexBuffer)&&this.textVertexBuffer.dispose(),u(this.textOpacityBuffer)&&this.textOpacityBuffer.dispose(),u(this.textIndexBuffer)&&this.textIndexBuffer.dispose(),this.textVertexArrayObject=null,this.textVertexBuffer=null,this.textOpacityBuffer=null,this.textIndexBuffer=null,this.memoryUsed=0}updateOpacityInfo(){if(!this.opacityChanged)return;this.opacityChanged=!1;const e=m(this.iconOpacity),r=m(this.iconOpacityBuffer);e.length>0&&e.byteLength===r.size&&r.setSubData(e,0,0,e.length);const t=m(this.textOpacity),s=m(this.textOpacityBuffer);t.length>0&&t.byteLength===s.size&&s.setSubData(t,0,0,t.length)}doPrepareForRendering(e,r,t){const s=new Uint32Array(r),a=new Int32Array(s.buffer),i=s[t++];this.iconVertexBuffer=d.createVertex(e,x.STATIC_DRAW,new Int32Array(a.buffer,4*t,i)),t+=i;const n=s[t++];this.iconIndexBuffer=d.createIndex(e,x.STATIC_DRAW,new Uint32Array(s.buffer,4*t,n)),t+=n;const o=s[t++];this.textVertexBuffer=d.createVertex(e,x.STATIC_DRAW,new Int32Array(a.buffer,4*t,o)),t+=o;const c=s[t++];this.textIndexBuffer=d.createIndex(e,x.STATIC_DRAW,new Uint32Array(s.buffer,4*t,c)),t+=c,this.iconOpacityBuffer=d.createVertex(e,x.STATIC_DRAW,m(this.iconOpacity).buffer),this.textOpacityBuffer=d.createVertex(e,x.STATIC_DRAW,m(this.textOpacity).buffer);const y=this.layer,f=y.iconMaterial,h=y.textMaterial;this.iconVertexArrayObject=new g(e,f.getAttributeLocations(),f.getLayoutInfo(),{geometry:this.iconVertexBuffer,opacity:this.iconOpacityBuffer},this.iconIndexBuffer),this.textVertexArrayObject=new g(e,h.getAttributeLocations(),h.getLayoutInfo(),{geometry:this.textVertexBuffer,opacity:this.textOpacityBuffer},this.textIndexBuffer)}}class N extends A{constructor(e,r){super(e,r),this.type=p.CIRCLE,this.circleIndexStart=0,this.circleIndexCount=0;const t=new Uint32Array(e);let s=this.bufferDataOffset;this.circleIndexStart=t[s++],this.circleIndexCount=t[s++],this.bufferDataOffset=s}hasData(){return this.circleIndexCount>0}triangleCount(){return this.circleIndexCount/3}doDestroy(){u(this.circleVertexArrayObject)&&this.circleVertexArrayObject.dispose(),u(this.circleVertexBuffer)&&this.circleVertexBuffer.dispose(),u(this.circleIndexBuffer)&&this.circleIndexBuffer.dispose(),this.circleVertexArrayObject=null,this.circleVertexBuffer=null,this.circleIndexBuffer=null,this.memoryUsed=0}doPrepareForRendering(e,r,t){const s=new Uint32Array(r),a=new Int32Array(s.buffer),i=s[t++];this.circleVertexBuffer=d.createVertex(e,x.STATIC_DRAW,new Int32Array(a.buffer,4*t,i)),t+=i;const n=s[t++];this.circleIndexBuffer=d.createIndex(e,x.STATIC_DRAW,new Uint32Array(s.buffer,4*t,n)),t+=n;const o=this.layer.circleMaterial;this.circleVertexArrayObject=new g(e,o.getAttributeLocations(),o.getLayoutInfo(),{geometry:this.circleVertexBuffer},this.circleIndexBuffer)}}class w extends E{constructor(e,r,t,s,a,i,n,o=null){super(e,r,t,s,a,i,4096,4096),this._memCache=o,this.type="vector-tile",this._referenced=0,this._hasSymbolBuckets=!1,this._memoryUsedByLayerData=0,this.layerData=new Map,this.layerCount=0,this.status="loading",this.allSymbolsFadingOut=!1,this.lastOpacityUpdate=0,this.symbols=new Map,this.isCoverage=!1,this.neededForCoverage=!1,this.decluttered=!1,this.invalidating=!1,this.parentTile=null,this.childrenTiles=new Set,this._processed=!1,this._referenced=1,this.styleRepository=n,this.id=e.id}get hasSymbolBuckets(){return this._hasSymbolBuckets}get isFading(){return this._hasSymbolBuckets&&performance.now()-this.lastOpacityUpdate<_}get isHoldingForFade(){return this._hasSymbolBuckets&&(!this.allSymbolsFadingOut||performance.now()-this.lastOpacityUpdate<_)}get wasRequested(){return this.status==="errored"||this.status==="loaded"||this.status==="reloading"}setData(e){this.changeDataImpl(e),this.requestRender(),this.ready(),this.invalidating=!1,this._processed=!0}deleteLayerData(e){let r=!1;for(const t of e)if(this.layerData.has(t)){const s=this.layerData.get(t);this._memoryUsedByLayerData-=s.memoryUsed,s.type===p.SYMBOL&&this.symbols.has(t)&&(this.symbols.delete(t),r=!0),s.destroy(),this.layerData.delete(t),this.layerCount--}u(this._memCache)&&this._memCache.updateSize(this.key.id,this,this._memoryUsedByLayerData),r&&this.emit("symbols-changed"),this.requestRender()}processed(){return this._processed}hasData(){return this.layerCount>0}dispose(){this.status!=="unloaded"&&(V.delete(this),w._destroyRenderBuckets(this.layerData),this.layerData=null,this.layerCount=0,this._memoryUsedByLayerData=0,this.destroy(),this.status="unloaded")}release(){return--this._referenced==0&&(this.dispose(),this.stage=null,!0)}retain(){++this._referenced}get referenced(){return this._referenced}get memoryUsage(){return(this._memoryUsedByLayerData+256)/(this._referenced||1)}changeDataImpl(e){let r=!1;if(e){const{bucketsWithData:t,emptyBuckets:s}=e,a=this._createRenderBuckets(t);if(s&&s.byteLength>0){const i=new Uint32Array(s);for(const n of i)this._deleteLayerData(n)}for(const[i,n]of a)this._deleteLayerData(i),n.type===p.SYMBOL&&(this.symbols.set(i,n.symbols),r=!0),this._memoryUsedByLayerData+=n.memoryUsed,this.layerData.set(i,n),this.layerCount++;u(this._memCache)&&this._memCache.updateSize(this.key.id,this,this._memoryUsedByLayerData)}this._hasSymbolBuckets=!1;for(const[t,s]of this.layerData)s.type===p.SYMBOL&&(this._hasSymbolBuckets=!0);r&&this.emit("symbols-changed")}attachWithContext(e){this.stage={context:e,trashDisplayObject(r){r.processDetach()},untrashDisplayObject:()=>!1}}setTransform(e){super.setTransform(e);const r=this.resolution/(e.resolution*e.pixelRatio),t=this.width/this.rangeX*r,s=this.height/this.rangeY*r,a=[0,0];e.toScreen(a,[this.x,this.y]);const i=this.transforms.tileUnitsToPixels;P(i),j(i,i,a),F(i,i,Math.PI*e.rotation/180),k(i,i,[t,s,1])}_createTransforms(){return{dvs:O(),tileMat3:O(),tileUnitsToPixels:O()}}static _destroyRenderBuckets(e){if(!e)return;const r=new Set;e.forEach(t=>{r.has(t)||(t.destroy(),r.add(t))}),e.clear()}_createRenderBuckets(e){const r=new Map,t=new Map;for(const s of e){const a=this._deserializeBucket(s,t);for(const i of a.layerUIDs)r.set(i,a)}return r}_deserializeBucket(e,r){let t=r.get(e);if(t)return t;switch(new Uint32Array(e)[0]){case p.FILL:t=new v(e,this.styleRepository);break;case p.LINE:t=new Y(e,this.styleRepository);break;case p.SYMBOL:t=new q(e,this.styleRepository,this);break;case p.CIRCLE:t=new N(e,this.styleRepository)}return r.set(e,t),t}_deleteLayerData(e){if(!this.layerData.has(e))return;const r=this.layerData.get(e);this._memoryUsedByLayerData-=r.memoryUsed,r.destroy(),this.layerData.delete(e),this.layerCount--}}const V=new Map;function at(){V.forEach((l,e)=>{console.log(`
${e.key}:`),l[0].forEach(r=>console.log(r)),console.log("========"),l[1].forEach(r=>console.log(r))})}export{et as a,it as i,w as m,st as o,at as p,Z as s};
