import"./geometry-b7901087.js";import{t as y,r as D}from"./typedArrayUtil-4d7bb04c.js";import{f as R}from"./promiseUtils-1e54421e.js";import{v as C}from"./dehydratedFeatures-0557137d.js";import{a as F}from"./elevationInfoUtils-36e5dd0f.js";import{F as q,H as z,aH as G,as as H,aI as O}from"./index-b7900c1e.js";import{k}from"./Extent-da876e26.js";import{i as E}from"./arcadeOnDemand-281a01eb.js";async function N(r,p,d,I,s){const{elevationProvider:m,renderCoordsHelper:i,spatialReference:b}=r,{elevationInfo:h}=p,g=q(h,!0),v=await z(g,b,s);R(s);const c=[],f=new Set,u=new Set;for(const{objectId:e,points:n}of I){const t=d(e);if(y(t)){for(const a of n)c.push(a[2]);f.add(e);continue}t.isDraped&&u.add(e);const o=t.graphic.geometry;w.setFromElevationInfo(F(o,h)),w.updateFeatureExpressionInfoContext(v,t.graphic,p),l.spatialReference=r.spatialReference;for(const{x:a,y:$,z:x}of n)l.x=a,l.y=$,l.z=x??0,G(l,m,w,i,S),c.push(S.z)}return{elevations:c,drapedObjectIds:u,failedObjectIds:f}}const w=new H,l=C(0,0,0,k.WGS84),S=new O;async function Q(r,p,d){if(y(r)||p.candidates.length===0)return j;const I=r.graphics3DGraphicsByObjectID??r.graphics3DGraphics,s=[],m=[],{renderer:i}=r,b=D(i)&&"arcadeRequired"in i&&i.arcadeRequired?E():null,h=async(e,{graphic:n,graphics3DSymbol:t})=>{const o=await b,a=await r.getRenderingInfoAsync(n,i,o,{signal:d});return y(a)?[]:t.queryForSnapping(e,v,a,d)},{candidates:g,spatialReference:v}=p;for(let e=0;e<g.length;++e){const n=g[e],{objectId:t}=n,o=typeof t=="number"?I.get(t):void 0;if(y(o))continue;const{graphics3DSymbol:a}=o;a.symbologySnappingSupported&&(s.push(h(n,o)),m.push(e))}if(s.length===0)return j;const c=await Promise.all(s);R(d);const f=[],u=[];for(let e=0;e<c.length;++e){const n=c[e],t=m[e];for(const o of n)f.push(o),u.push(t)}return{candidates:f,sourceCandidateIndices:u}}const j={candidates:[],sourceCandidateIndices:[]};export{Q as a,N as m};
