import{R as l,iN as A,G as c,c2 as S,f0 as d}from"./calcite-8912bd40.js";import{S as y}from"./quat-7b70e9a8.js";import{e as D}from"./quatf32-51a323b8.js";import{r as M,n as h}from"./vec3f32-01c06d8d.js";import{c as g,a as m,f as w,m as z}from"./PointCloudWorkerUtil-e60ffde3.js";import"./index-00759e4a.js";import"./mat3f64-50f3b9f6.js";import"./quatf64-f8f1c132.js";import"./PointCloudUniqueValueRenderer-00dd1cae.js";import"./I3SBinaryReader-533328a5.js";import"./VertexAttribute-15d1866a.js";class _{transform(t){const r=this._transform(t),e=[r.points.buffer,r.rgb.buffer];l(r.pointIdFilterMap)&&e.push(r.pointIdFilterMap.buffer);for(const a of r.attributes)"buffer"in a.values&&A(a.values.buffer)&&a.values.buffer!==r.rgb.buffer&&e.push(a.values.buffer);return Promise.resolve({result:r,transferList:e})}_transform(t){const r=g(t.schema,t.geometryBuffer);let e=r.length/3,a=null;const n=[],s=m(t.primaryAttributeData,r,e);l(t.primaryAttributeData)&&s&&n.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:s});const i=m(t.modulationAttributeData,r,e);l(t.modulationAttributeData)&&i&&n.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:i});let f=w(t.rendererInfo,s,i,e);if(t.filterInfo&&t.filterInfo.length>0&&l(t.filterAttributesData)){const o=t.filterAttributesData.filter(l).map(b=>{const v=m(b,r,e),p={attributeInfo:b.attributeInfo,values:v};return n.push(p),p});a=new Uint32Array(e),e=z(r,f,a,t.filterInfo,o)}for(const o of t.userAttributesData){const b=m(o,r,e);n.push({attributeInfo:o.attributeInfo,values:b})}3*e<f.length&&(f=new Uint8Array(f.buffer.slice(0,3*e))),this._applyElevationOffsetInPlace(r,e,t.elevationOffset);const u=this._transformCoordinates(r,e,t.obb,c.fromJSON(t.inSR),c.fromJSON(t.outSR));return{obb:t.obb,points:u,rgb:f,attributes:n,pointIdFilterMap:a}}_transformCoordinates(t,r,e,a,n){if(!S(t,a,0,t,n,0,r))throw new Error("Can't reproject");const s=M(e.center[0],e.center[1],e.center[2]),i=h(),f=h();y(I,e.quaternion);const u=new Float32Array(3*r);for(let o=0;o<r;o++)i[0]=t[3*o]-s[0],i[1]=t[3*o+1]-s[1],i[2]=t[3*o+2]-s[2],d(f,i,I),e.halfSize[0]=Math.max(e.halfSize[0],Math.abs(f[0])),e.halfSize[1]=Math.max(e.halfSize[1],Math.abs(f[1])),e.halfSize[2]=Math.max(e.halfSize[2],Math.abs(f[2])),u[3*o]=i[0],u[3*o+1]=i[1],u[3*o+2]=i[2];return u}_applyElevationOffsetInPlace(t,r,e){if(e!==0)for(let a=0;a<r;a++)t[3*a+2]+=e}}const I=D();function q(){return new _}export{q as default};
