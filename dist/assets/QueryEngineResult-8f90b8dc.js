import{_ as ce}from"./preload-helper-3bce6601.js";import{t as ae,r as Y}from"./typedArrayUtil-4d7bb04c.js";import{l as de,n as H,r as he,p as fe}from"./Polyline-ff2d7c6b.js";import{s as U}from"./quantizationUtils-4dd81f85.js";import{I as me,E as X}from"./Extent-da876e26.js";import{a as S}from"./Error-ec6249b9.js";import{e as k}from"./ItemCache-fd3aceaf.js";import{WhereClause as ge}from"./WhereClause-d4b8b019.js";import{c as P,x as pe,m as ye,f as W,d as J,V as xe,T as Fe,F as Ie,D as _e,N as Ve,S as Te,v as De,p as ve}from"./utils-b34fcd9d.js";import{g as K}from"./projectionSupport-aa5eaa0d.js";import{e as Ae,t as ze}from"./SnappingCandidate-970faec6.js";import{E as G,v as O,b as ee}from"./utils-511aa5f5.js";import{t as te}from"./fieldUtils-7f54c4b1.js";import{i as be}from"./arcadeOnDemand-281a01eb.js";let Se=class{constructor(t,e){this._cache=new k(t),this._invalidCache=new k(e)}get(t,e){const i=`${e.uid}:${t}`,a=this._cache.get(i);if(a)return a;if(this._invalidCache.get(i)!==void 0)return null;try{const s=ge.create(t,e);return this._cache.put(i,s),s}catch{return this._invalidCache.put(i,null),null}}};const Z=new Se(50,500),w="feature-store:unsupported-query",re=" as ",we=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function Ue(d,t){if(!t)return!0;const e=Z.get(t,d);if(!e)throw new S(w,"invalid SQL expression",{where:t});if(!e.isStandardized)throw new S(w,"where clause is not standard",{where:t});return Q(d,e.fieldNames,"where clause contains missing fields"),!0}function Xe(d,t,e){if(!t)return!0;const i=Z.get(t,d);if(!i)throw new S(w,"invalid SQL expression",{having:t});if(!i.isAggregate)throw new S(w,"having does not contain a valid aggregate function",{having:t});const a=i.fieldNames;if(Q(d,a,"having contains missing fields"),!i.getExpressions().every(s=>{const{aggregateType:r,field:n}=s,o=d.has(n)&&d.get(n).name;return e.some(u=>{const{onStatisticField:l,statisticType:c}=u;return(d.has(l)&&d.get(l).name)===o&&c.toLowerCase().trim()===r})}))throw new S(w,"expressions in having should also exist in outStatistics",{having:t});return!0}function q(d,t){return d?Z.get(d,t):null}function Q(d,t,e,i=!0){const a=[];for(const s of t)if(s!=="*"&&!d.has(s))if(i){const r=ne(s);try{const n=q(r,d);if(!n)throw new S(w,"invalid SQL expression",{where:r});if(!n.isStandardized)throw new S(w,"expression is not standard",{clause:n});Q(d,n.fieldNames,"expression contains missing fields")}catch(n){const o=n&&n.details;if(o&&(o.clause||o.where))throw n;o&&o.missingFields?a.push(...o.missingFields):a.push(s)}}else a.push(s);if(a.length)throw new S(w,e,{missingFields:a})}function ne(d){return d.split(re)[0]}function Ee(d){return d.split(re)[1]}function ke(d,t){const e=t.get(d);return!!e&&!we.has(e.type)}class ${constructor(t,e,i){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=t.returnDistinctValues??!1,this.fieldsIndex=i,this.featureAdapter=e;const a=t.outFields;if(a&&!a.includes("*")){this.outFields=a;let s=0;for(const r of a){const n=ne(r),o=this.fieldsIndex.get(n),u=o?null:q(n,i),l=o?o.name:Ee(r)||"FIELD_EXP_"+s++;this._fieldDataCache.set(r,{alias:l,clause:u})}}}countDistinctValues(t){return this.returnDistinctValues?(t.forEach(e=>this.getAttributes(e)),this._returnDistinctMap.size):t.length}getAttributes(t){const e=this._processAttributesForOutFields(t);return this._processAttributesForDistinctValues(e)}getFieldValue(t,e,i){const a=i?i.name:e;let s=null;return this._fieldDataCache.has(a)?s=this._fieldDataCache.get(a).clause:i||(s=q(e,this.fieldsIndex),this._fieldDataCache.set(a,{alias:a,clause:s})),i?this.featureAdapter.getAttribute(t,a):s.calculateValue(t,this.featureAdapter)}getDataValue(t,e){const i=e.normalizationType,a=e.normalizationTotal;let s=this.getFieldValue(t,e.field,this.fieldsIndex.get(e.field));if(e.field2&&(s=`${P(s)}${e.fieldDelimiter}${P(this.getFieldValue(t,e.field2,this.fieldsIndex.get(e.field2)))}`,e.field3&&(s=`${s}${e.fieldDelimiter}${P(this.getFieldValue(t,e.field3,this.fieldsIndex.get(e.field3)))}`)),i&&Number.isFinite(s)){const r=i==="field"&&e.normalizationField?this.getFieldValue(t,e.normalizationField,this.fieldsIndex.get(e.normalizationField)):null;s=pe(s,i,r,a)}return s}getExpressionValue(t,e,i,a){const s={attributes:this.featureAdapter.getAttributes(t),layer:{fields:this.fieldsIndex.fields}},r=a.createExecContext(s,i);return a.executeFunction(e,r)}getExpressionValues(t,e,i,a){const s={fields:this.fieldsIndex.fields};return t.map(r=>{const n={attributes:this.featureAdapter.getAttributes(r),layer:s},o=a.createExecContext(n,i);return a.executeFunction(e,o)})}validateItem(t,e){return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:q(e,this.fieldsIndex)}),this._fieldDataCache.get(e).clause.testFeature(t,this.featureAdapter)}validateItems(t,e){return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:q(e,this.fieldsIndex)}),this._fieldDataCache.get(e).clause.testSet(t,this.featureAdapter)}_processAttributesForOutFields(t){const e=this.outFields;if(!e||!e.length)return this.featureAdapter.getAttributes(t);const i={};for(const a of e){const{alias:s,clause:r}=this._fieldDataCache.get(a);i[s]=r?r.calculateValue(t,this.featureAdapter):this.featureAdapter.getAttribute(t,s)}return i}_processAttributesForDistinctValues(t){if(ae(t)||!this.returnDistinctValues)return t;const e=this.outFields,i=[];if(e)for(const r of e){const{alias:n}=this._fieldDataCache.get(r);i.push(t[n])}else for(const r in t)i.push(t[r]);const a=`${(e||["*"]).join(",")}=${i.join(",")}`;let s=this._returnDistinctMap.get(a)||0;return this._returnDistinctMap.set(a,++s),s>1?null:t}}class We{constructor(t,e,i){this.items=t,this.query=e,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const t=new $(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return t.countDistinctValues(this.items);const{groupByFieldsForStatistics:e,having:i,outStatistics:a}=this.query;if(!(e==null?void 0:e.length))return 1;const r=new Map,n=new Map,o=new Set;for(const u of a){const{statisticType:l}=u,c=l!=="exceedslimit"?u.onStatisticField:void 0;if(!n.has(c)){const h=[];for(const g of e){const x=this._getAttributeValues(t,g,r);h.push(x)}n.set(c,this._calculateUniqueValues(h,t.returnDistinctValues))}const f=n.get(c);for(const h in f){const{data:g,items:x}=f[h],V=g.join(",");i&&!t.validateItems(x,i)||o.add(V)}}return o.size}async createQueryResponse(){let t;return this.query.outStatistics?t=this.query.outStatistics.some(e=>e.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query):t=this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry&&(me(this.query.outSR)&&!X(this.query.geometry.spatialReference,this.query.outSR)?t.queryGeometry=G({spatialReference:this.query.outSR,...K(this.query.geometry,this.query.geometry.spatialReference,this.query.outSR)}):t.queryGeometry=G({spatialReference:this.query.outSR,...this.query.geometry})),t}createSnappingResponse(t,e){const i=this.featureAdapter,a=ie(this.hasZ,this.hasM),{point:s}=t,r=typeof t.distance=="number"?t.distance:t.distance.x,n=typeof t.distance=="number"?t.distance:t.distance.y,o={candidates:[]},u=this.geometryType==="esriGeometryPolygon",l=s.z!=null,c=s.m!=null,f=this._getPointCreator(s,l,c,this.spatialReference,e),h=new se(null,0),g=new se(null,0),x={x:0,y:0,z:0};for(const V of this.items){const y=i.getGeometry(V);if(ae(y))continue;const{coords:I,lengths:_}=y;if(h.coords=I,g.coords=I,t.types&M.EDGE){let F=0;for(let p=0;p<_.length;p++){const m=_[p];for(let T=0;T<m;T++,F+=a){const v=h;if(v.coordsIndex=F,T!==m-1){const z=g;z.coordsIndex=F+a;const D=x;Ce(x,s,v,z);const A=(s.x-D.x)/r,C=(s.y-D.y)/n,E=A*A+C*C;E<=1&&o.candidates.push(Ae(i.getObjectId(V),f(D),Math.sqrt(E),f(v),f(z)))}}}}if(t.types&M.VERTEX){const F=u?I.length-a:I.length;for(let p=0;p<F;p+=a){const m=h;m.coordsIndex=p;const T=(s.x-m.x)/r,v=(s.y-m.y)/n,z=T*T+v*v;z<=1&&o.candidates.push(ze(i.getObjectId(V),f(m),Math.sqrt(z)))}}}return o.candidates.sort((V,y)=>V.distance-y.distance),o}_getPointCreator(t,e,i,a,s){const r=Y(s)&&!X(a,s)?l=>K(l,a,s):l=>l,{hasZ:n}=this,o=0,u=t.m;return e&&i?n?({x:l,y:c,z:f})=>r({x:l,y:c,z:f,m:u}):({x:l,y:c})=>r({x:l,y:c,z:o,m:u}):e?n?({x:l,y:c,z:f})=>r({x:l,y:c,z:f}):({x:l,y:c})=>r({x:l,y:c,z:o}):i?({x:l,y:c})=>r({x:l,y:c,m:u}):({x:l,y:c})=>r({x:l,y:c})}async createSummaryStatisticsResponse(t){const{field:e,valueExpression:i,normalizationField:a,normalizationType:s,normalizationTotal:r,minValue:n,maxValue:o,scale:u}=t,l=this.fieldsIndex.isDateField(e),c=await this._getDataValues({field:e,valueExpression:i,normalizationField:a,normalizationType:s,normalizationTotal:r,scale:u}),f=ye({normalizationType:s,normalizationField:a,minValue:n,maxValue:o}),h=this.fieldsIndex.get(e),g={value:.5,fieldType:h==null?void 0:h.type},x=te(h)?W({values:c,supportsNullCount:f,percentileParams:g}):J({values:c,minValue:n,maxValue:o,useSampleStdDev:!s,supportsNullCount:f,percentileParams:g});return xe(x,l)}async createUniqueValuesResponse(t){const{field:e,valueExpression:i,domains:a,returnAllCodedValues:s,scale:r}=t,n=await this._getDataValues({field:e,field2:t.field2,field3:t.field3,fieldDelimiter:t.fieldDelimiter,valueExpression:i,scale:r}),o=Fe(n);return Ie(o,a,s,t.fieldDelimiter)}async createClassBreaksResponse(t){const{field:e,valueExpression:i,normalizationField:a,normalizationType:s,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:u,maxValue:l,numClasses:c,scale:f}=t,h=await this._getDataValues({field:e,valueExpression:i,normalizationField:a,normalizationType:s,normalizationTotal:r,scale:f}),g=_e(h,{field:e,normalizationField:a,normalizationType:s,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:u,maxValue:l,numClasses:c});return Ve(g,n)}async createHistogramResponse(t){const{field:e,valueExpression:i,normalizationField:a,normalizationType:s,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:u,maxValue:l,numBins:c,scale:f}=t,h=await this._getDataValues({field:e,valueExpression:i,normalizationField:a,normalizationType:s,normalizationTotal:r,scale:f});return Te(h,{field:e,normalizationField:a,normalizationType:s,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:u,maxValue:l,numBins:c})}_sortFeatures(t,e,i){if(t.length>1&&e&&e.length)for(const a of e.reverse()){const s=a.split(" "),r=s[0],n=this.fieldsIndex.get(r),o=s[1]&&s[1].toLowerCase()==="desc",u=De(n==null?void 0:n.type,o);t.sort((l,c)=>{const f=i(l,r,n),h=i(c,r,n);return u(f,h)})}}_createFeatureQueryResponse(t){const e=this.items,{geometryType:i,hasM:a,hasZ:s,objectIdField:r,spatialReference:n}=this,{outFields:o,outSR:u,quantizationParameters:l,resultRecordCount:c,resultOffset:f,returnZ:h,returnM:g}=t,x=c!=null&&e.length>(f||0)+c,V=o&&(o.includes("*")?[...this.fieldsIndex.fields]:o.map(y=>this.fieldsIndex.get(y)));return{exceededTransferLimit:x,features:this._createFeatures(t,e),fields:V,geometryType:i,hasM:a&&g,hasZ:s&&h,objectIdFieldName:r,spatialReference:G(u||n),transform:l&&U(l)||null}}_createFeatures(t,e){const i=new $(t,this.featureAdapter,this.fieldsIndex),{hasM:a,hasZ:s}=this,{orderByFields:r,quantizationParameters:n,returnGeometry:o,returnCentroid:u,maxAllowableOffset:l,resultOffset:c,resultRecordCount:f,returnZ:h=!1,returnM:g=!1}=t,x=s&&h,V=a&&g;let y=[],I=0;const _=[...e];if(this._sortFeatures(_,r,(p,m,T)=>i.getFieldValue(p,m,T)),o||u){const p=U(n);if(o&&!u)for(const m of _)y[I++]={attributes:i.getAttributes(m),geometry:O(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(m),l,p,x,V)};else if(!o&&u)for(const m of _)y[I++]={attributes:i.getAttributes(m),centroid:ee(this,this.featureAdapter.getCentroid(m,this),p)};else for(const m of _)y[I++]={attributes:i.getAttributes(m),centroid:ee(this,this.featureAdapter.getCentroid(m,this),p),geometry:O(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(m),l,p,x,V)}}else for(const p of _){const m=i.getAttributes(p);m&&(y[I++]={attributes:m})}const F=c||0;if(f!=null){const p=F+f;y=y.slice(F,Math.min(y.length,p))}return y}_createExceedsLimitQueryResponse(t){let e=!1,i=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY;for(const r of t.outStatistics)if(r.statisticType==="exceedslimit"){i=r.maxPointCount!=null?r.maxPointCount:Number.POSITIVE_INFINITY,a=r.maxRecordCount!=null?r.maxRecordCount:Number.POSITIVE_INFINITY,s=r.maxVertexCount!=null?r.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")e=this.items.length>i;else if(this.items.length>a)e=!0;else{const r=ie(this.hasZ,this.hasM),n=this.featureAdapter;e=this.items.reduce((o,u)=>{const l=n.getGeometry(u);return o+(Y(l)&&l.coords.length||0)},0)/r>s}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(e)}}]}}async _createStatisticsQueryResponse(t){const e={attributes:{}},i=[],a=new Map,s=new Map,r=new Map,n=new Map,o=new $(t,this.featureAdapter,this.fieldsIndex),u=t.outStatistics,{groupByFieldsForStatistics:l,having:c,orderByFields:f}=t,h=l&&l.length,g=!!h,x=g&&l[0],V=g&&!this.fieldsIndex.get(x);for(const I of u){const{outStatisticFieldName:_,statisticType:F}=I,p=I,m=F!=="exceedslimit"?I.onStatisticField:void 0,T=F==="percentile_disc"||F==="percentile_cont",v=F==="EnvelopeAggregate"||F==="CentroidAggregate"||F==="ConvexHullAggregate",z=g&&h===1&&(m===x||V)&&F==="count";if(g){if(!r.has(m)){const A=[];for(const C of l){const E=this._getAttributeValues(o,C,a);A.push(E)}r.set(m,this._calculateUniqueValues(A,!v&&o.returnDistinctValues))}const D=r.get(m);for(const A in D){const{count:C,data:E,items:j,itemPositions:oe}=D[A],L=E.join(",");if(!c||o.validateItems(j,c)){const R=n.get(L)||{attributes:{}};if(v){R.aggregateGeometries||(R.aggregateGeometries={});const{aggregateGeometries:b,outStatisticFieldName:N}=await this._getAggregateGeometry(p,j);R.aggregateGeometries[N]=b}else{let b=null;if(z)b=C;else{const N=this._getAttributeValues(o,m,a),B=oe.map(ue=>N[ue]);b=T&&"statisticParameters"in p?this._getPercentileValue(p,B):this._getStatisticValue(p,B,null,o.returnDistinctValues)}R.attributes[_]=b}let le=0;l.forEach((b,N)=>R.attributes[this.fieldsIndex.get(b)?b:"EXPR_"+ ++le]=E[N]),n.set(L,R)}}}else if(v){e.aggregateGeometries||(e.aggregateGeometries={});const{aggregateGeometries:D,outStatisticFieldName:A}=await this._getAggregateGeometry(p,this.items);e.aggregateGeometries[A]=D}else{const D=this._getAttributeValues(o,m,a);e.attributes[_]=T&&"statisticParameters"in p?this._getPercentileValue(p,D):this._getStatisticValue(p,D,s,o.returnDistinctValues)}i.push({name:_,alias:_,type:"esriFieldTypeDouble"})}const y=g?Array.from(n.values()):[e];return this._sortFeatures(y,f,(I,_)=>I.attributes[_]),{fields:i,features:y}}async _getAggregateGeometry(t,e){const i=await ce(()=>import("./geometryEngineJSON-a45b7108.js"),["assets/geometryEngineJSON-a45b7108.js","assets/geometryEngineBase-3dd302e0.js","assets/geometryEngineJSON-45c195fe.js","assets/json-48e3ea08.js"]),{statisticType:a,outStatisticFieldName:s}=t,{featureAdapter:r,spatialReference:n,geometryType:o,hasZ:u,hasM:l}=this,c=e.map(g=>O(o,u,l,r.getGeometry(g))),f=i.convexHull(n,c,!0)[0],h={aggregateGeometries:null,outStatisticFieldName:null};if(a==="EnvelopeAggregate"){const g=f?de(f):H(i.union(n,c));h.aggregateGeometries={...g,spatialReference:n},h.outStatisticFieldName=s||"extent"}else if(a==="CentroidAggregate"){const g=f?he(f):fe(H(i.union(n,c)));h.aggregateGeometries={x:g[0],y:g[1],spatialReference:n},h.outStatisticFieldName=s||"centroid"}else a==="ConvexHullAggregate"&&(h.aggregateGeometries=f,h.outStatisticFieldName=s||"convexHull");return h}_getStatisticValue(t,e,i,a){const{onStatisticField:s,statisticType:r}=t;let n=null;return n=i!=null&&i.has(s)?i.get(s):te(this.fieldsIndex.get(s))?W({values:e,returnDistinct:a}):J({values:e,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(s,n),n[r==="var"?"variance":r]}_getPercentileValue(t,e){const{onStatisticField:i,statisticParameters:a,statisticType:s}=t,{value:r,orderBy:n}=a,o=this.fieldsIndex.get(i);return ve(e,{value:r,orderBy:n,fieldType:o==null?void 0:o.type,isDiscrete:s==="percentile_disc"})}_getAttributeValues(t,e,i){if(i.has(e))return i.get(e);const a=this.fieldsIndex.get(e),s=this.items.map(r=>t.getFieldValue(r,e,a));return i.set(e,s),s}_getAttributeDataValues(t,e){return this.items.map(i=>t.getDataValue(i,{field:e.field,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal}))}async _getAttributeExpressionValues(t,e,i){const{arcadeUtils:a}=await be(),s=a.createFunction(e),r=i&&a.getViewInfo(i);return t.getExpressionValues(this.items,s,r,a)}_calculateUniqueValues(t,e){const i={},a=this.items,s=a.length;for(let r=0;r<s;r++){const n=a[r],o=[];for(const l of t)o.push(l[r]);const u=o.join(",");e?i[u]==null&&(i[u]={count:1,data:o,items:[n],itemPositions:[r]}):i[u]==null?i[u]={count:1,data:o,items:[n],itemPositions:[r]}:(i[u].count++,i[u].items.push(n),i[u].itemPositions.push(r))}return i}async _getDataValues(t){const e=new $(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:i,field:a,normalizationField:s,normalizationType:r,normalizationTotal:n,scale:o}=t,u=i?{viewingMode:"map",scale:o,spatialReference:this.query.outSR||this.spatialReference}:null;return i?this._getAttributeExpressionValues(e,i,u):this._getAttributeDataValues(e,{field:a,field2:t.field2,field3:t.field3,fieldDelimiter:t.fieldDelimiter,normalizationField:s,normalizationType:r,normalizationTotal:n})}}function Ce(d,t,e,i){const a=i.x-e.x,s=i.y-e.y,r=a*a+s*s,n=(t.x-e.x)*a+(t.y-e.y)*s,o=Math.min(1,Math.max(0,n/r));d.x=e.x+a*o,d.y=e.y+s*o}function ie(d,t){return d?t?4:3:t?3:2}var M;(function(d){d[d.NONE=0]="NONE",d[d.EDGE=1]="EDGE",d[d.VERTEX=2]="VERTEX"})(M||(M={}));class se{constructor(t,e){this.coords=t,this.coordsIndex=e}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}export{We as A,Xe as a,Q as c,ke as f,q as l,Ue as o,M as q};
