import{U as O}from"./request-6fc81c4c.js";import{j as k}from"./asyncUtils-437defc4.js";import{a as g,s as C}from"./Error-ec6249b9.js";import{r as E}from"./typedArrayUtil-4d7bb04c.js";import{j as D}from"./promiseUtils-1e54421e.js";import{c as q}from"./jsonUtils-229211af.js";import{F as _,E as Q}from"./Extent-da876e26.js";import{n as G,r as M,t as P,o as Z,X as A}from"./featureConversionUtils-03a03f40.js";import{u as v}from"./FeatureStore-3cfbdfa3.js";import{f as F,g as b}from"./projectionSupport-aa5eaa0d.js";import{Y as N}from"./QueryEngine-cdb0ba2c.js";import{L as z,I as U,T as B}from"./geojson-8e4c2449.js";import{o as L,a as J,i as V}from"./clientSideDefaults-8609abb2.js";import{w as W,m as w,f as T,a as I,g as x}from"./sourceUtils-77beff52.js";import{r as S}from"./FieldsIndex-f104cc5f.js";import{i as Y}from"./fieldType-f31285f7.js";import{M as H}from"./fieldUtils-7f54c4b1.js";import"./preload-helper-3bce6601.js";import"./string-a318751c.js";import"./cast-fcb46737.js";import"./ArrayPool-a8ee9378.js";import"./nextTick-3ee5a785.js";import"./Polyline-ff2d7c6b.js";import"./Ellipsoid-89682c5e.js";import"./OptimizedFeature-4ab8d380.js";import"./OptimizedFeatureSet-1d1ac4b9.js";import"./Evented-a45c8b0f.js";import"./aaBoundingBox-657a9b82.js";import"./aaBoundingRect-193543b5.js";import"./mathUtils-b4bb77e2.js";import"./vec3-e93e648f.js";import"./vec3f64-2f9cef06.js";import"./common-c186b691.js";import"./vec4-790471c0.js";import"./BoundsStore-b9fa27cc.js";import"./PooledRBush-3e149119.js";import"./quickselect-322ec8e1.js";import"./optimizedFeatureQueryEngineAdapter-d72f082e.js";import"./centroid-5c988df3.js";import"./projection-290b739f.js";import"./unitUtils-45d1147c.js";import"./jsonMap-7b8332c9.js";import"./SimpleObservable-23231131.js";import"./mat4-44a0988f.js";import"./assets-8d3e737a.js";import"./zscale-89472cba.js";import"./json-48e3ea08.js";import"./MemCache-18a255ed.js";import"./normalizeUtils-27e29a72.js";import"./geometry-b7901087.js";import"./typeUtils-35750739.js";import"./QueryEngineResult-8f90b8dc.js";import"./quantizationUtils-4dd81f85.js";import"./ItemCache-fd3aceaf.js";import"./WhereClause-d4b8b019.js";import"./utils-b34fcd9d.js";import"./generateRendererUtils-7252b5e6.js";import"./colorRamps-9dac42c1.js";import"./Color-fb64d77d.js";import"./colorUtils-639f4d25.js";import"./enumeration-3a03bd31.js";import"./Symbol-f93ed9fd.js";import"./SnappingCandidate-970faec6.js";import"./utils-511aa5f5.js";import"./arcadeOnDemand-281a01eb.js";import"./QueryEngineCapabilities-42e44ded.js";import"./timeSupport-3de56d7f.js";import"./Scheduler-540208b6.js";import"./reactiveUtils-4dabbb80.js";import"./defaultsJSON-59981e75.js";const X={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};class ft{constructor(){this._queryEngine=null,this._snapshotFeatures=async e=>{const t=await this._fetch(e);return this._createFeatures(t)}}destroy(){var e;(e=this._queryEngine)==null||e.destroy(),this._queryEngine=this._fieldsIndex=this._createDefaultAttributes=null}async load(e,t={}){this._loadOptions={url:e.url,customParameters:e.customParameters};const s=[];await this._checkProjection(e.spatialReference);let r=null;e.url&&(r=await this._fetch(t==null?void 0:t.signal));const n=z(r,{geometryType:e.geometryType}),o=e.fields||n.fields||[],l=e.hasZ!=null?e.hasZ:n.hasZ,u=n.geometryType;let m=e.objectIdField||n.objectIdFieldName||"__OBJECTID";const h=e.spatialReference||_;let i=e.timeInfo;o===n.fields&&n.unknownFields.length>0&&s.push({name:"geojson-layer:unknown-field-types",message:"Some fields types couldn't be inferred from the features and were dropped",details:{unknownFields:n.unknownFields}});let p=new S(o).get(m);p?(p.type!=="esriFieldTypeString"&&(p.type="esriFieldTypeOID"),p.editable=!1,p.nullable=!1,m=p.name):(p={alias:m,name:m,type:n.objectIdFieldType==="string"?"esriFieldTypeString":"esriFieldTypeOID",editable:!1,nullable:!1},o.unshift(p));const c={};for(const a of o){if(a.name==null&&(a.name=a.alias),a.alias==null&&(a.alias=a.name),!a.name)throw new g("geojson-layer:invalid-field-name","field name is missing",{field:a});if(!Y.jsonValues.includes(a.type))throw new g("geojson-layer:invalid-field-type",`invalid type for field "${a.name}"`,{field:a});if(a.name!==p.name){const f=H(a);f!==void 0&&(c[a.name]=f)}}this._fieldsIndex=new S(o);const d=this._fieldsIndex.requiredFields.indexOf(p);if(d>-1&&this._fieldsIndex.requiredFields.splice(d,1),i){if(i.startTimeField){const a=this._fieldsIndex.get(i.startTimeField);a?(i.startTimeField=a.name,a.type="esriFieldTypeDate"):i.startTimeField=null}if(i.endTimeField){const a=this._fieldsIndex.get(i.endTimeField);a?(i.endTimeField=a.name,a.type="esriFieldTypeDate"):i.endTimeField=null}if(i.trackIdField){const a=this._fieldsIndex.get(i.trackIdField);a?i.trackIdField=a.name:(i.trackIdField=null,s.push({name:"geojson-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:i}}))}i.startTimeField||i.endTimeField||(s.push({name:"geojson-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing",details:{timeInfo:i}}),i=null)}const R=u?L(u):null,y={warnings:s,featureErrors:[],layerDefinition:{...X,drawingInfo:R,templates:J(c),extent:null,geometryType:u,objectIdField:m,fields:o,hasZ:!!l,timeInfo:i}};this._queryEngine=new N({fields:o,geometryType:u,hasM:!1,hasZ:l,objectIdField:m,spatialReference:h,timeInfo:i,featureStore:new v({geometryType:u,hasM:!1,hasZ:l}),cacheSpatialQueries:!0}),this._createDefaultAttributes=V(c,m);const j=await this._createFeatures(r);this._objectIdGenerator=this._createObjectIdGenerator(this._queryEngine,j);const $=this._normalizeFeatures(j,y.warnings,y.featureErrors);if(this._queryEngine.featureStore.addMany($),y.layerDefinition.extent=this._queryEngine.fullExtent,y.layerDefinition.timeInfo){const{start:a,end:f}=this._queryEngine.timeExtent;y.layerDefinition.timeInfo.timeExtent=[a,f]}return y}async applyEdits(e){const{spatialReference:t,geometryType:s}=this._queryEngine;return await Promise.all([W(t,s),F(e.adds,t),F(e.updates,t)]),await this._waitSnapshotComplete(),this._applyEdits(e)}async queryFeatures(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQuery(e,t.signal)}async queryFeatureCount(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForCount(e,t.signal)}async queryObjectIds(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForIds(e,t.signal)}async queryExtent(e={},t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForExtent(e,t.signal)}async querySnapping(e,t={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForSnapping(e,t.signal)}async refresh(e){var t;return this._loadOptions.customParameters=e,(t=this._snapshotTask)==null||t.abort(),this._snapshotTask=k(this._snapshotFeatures),this._snapshotTask.promise.then(s=>{this._queryEngine.featureStore.clear(),this._objectIdGenerator=this._createObjectIdGenerator(this._queryEngine,s);const r=this._normalizeFeatures(s);r&&this._queryEngine.featureStore.addMany(r)},s=>{this._queryEngine.featureStore.clear(),D(s)||C.getLogger("esri.layers.GeoJSONLayer").error(new g("geojson-layer:refresh","An error occurred during refresh",{error:s}))}),await this._waitSnapshotComplete(),{extent:this._queryEngine.fullExtent,timeExtent:this._queryEngine.timeExtent}}async _createFeatures(e){const{geometryType:t,hasZ:s,objectIdField:r}=this._queryEngine,n=U(e,{geometryType:t,hasZ:s,objectIdField:r});if(!Q(this._queryEngine.spatialReference,_))for(const o of n)E(o.geometry)&&(o.geometry=G(b(M(o.geometry,this._queryEngine.geometryType,this._queryEngine.hasZ,!1),_,this._queryEngine.spatialReference)));return n}async _waitSnapshotComplete(){if(this._snapshotTask&&!this._snapshotTask.finished){try{await this._snapshotTask.promise}catch{}return this._waitSnapshotComplete()}}async _fetch(e){const{url:t,customParameters:s}=this._loadOptions,r=(await O(t,{responseType:"json",query:{...s},signal:e})).data;return await B(r),r}_normalizeFeatures(e,t,s){const{objectIdField:r}=this._queryEngine,n=[];for(const o of e){const l=this._createDefaultAttributes(),u=w(this._fieldsIndex,l,o.attributes,!0,t);u?s==null||s.push(u):(this._assignObjectId(l,o.attributes,!0),o.attributes=l,o.objectId=l[r],n.push(o))}return n}_applyEdits(e){const{adds:t,updates:s,deletes:r}=e,n={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if(t&&t.length&&this._applyAddEdits(n,t),s&&s.length&&this._applyUpdateEdits(n,s),r&&r.length){for(const o of r)n.deleteResults.push(T(o));this._queryEngine.featureStore.removeManyById(r)}return{extent:this._queryEngine.fullExtent,timeExtent:this._queryEngine.timeExtent,featureEditResults:n}}_applyAddEdits(e,t){const{addResults:s}=e,{geometryType:r,hasM:n,hasZ:o,objectIdField:l,spatialReference:u,featureStore:m}=this._queryEngine,h=[];for(const i of t){if(i.geometry&&r!==q(i.geometry)){s.push(I("Incorrect geometry type."));continue}const p=this._createDefaultAttributes(),c=w(this._fieldsIndex,p,i.attributes);if(c)s.push(c);else{if(this._assignObjectId(p,i.attributes),i.attributes=p,i.uid!=null){const d=i.attributes[l];e.uidToObjectId[i.uid]=d}if(E(i.geometry)){const d=i.geometry.spatialReference??u;i.geometry=b(x(i.geometry,d),d,u)}h.push(i),s.push(T(i.attributes[l]))}}m.addMany(P([],h,r,o,n,l))}_applyUpdateEdits({updateResults:e},t){const{geometryType:s,hasM:r,hasZ:n,objectIdField:o,spatialReference:l,featureStore:u}=this._queryEngine;for(const m of t){const{attributes:h,geometry:i}=m,p=h&&h[o];if(p==null){e.push(I(`Identifier field ${o} missing`));continue}if(!u.has(p)){e.push(I(`Feature with object id ${p} missing`));continue}const c=Z(u.getFeature(p),s,n,r);if(E(i)){if(s!==q(i)){e.push(I("Incorrect geometry type."));continue}const d=i.spatialReference??l;c.geometry=b(x(i,d),d,l)}if(h){const d=w(this._fieldsIndex,c.attributes,h);if(d){e.push(d);continue}}u.add(A(c,s,n,r,o)),e.push(T(p))}}_createObjectIdGenerator(e,t){const s=e.fieldsIndex.get(e.objectIdField);if(s.type==="esriFieldTypeString")return()=>s.name+"-"+Date.now().toString(16);let r=Number.NEGATIVE_INFINITY;for(const n of t)n.objectId&&(r=Math.max(r,n.objectId));return r=Math.max(0,r)+1,()=>r++}_assignObjectId(e,t,s=!1){const r=this._queryEngine.objectIdField;e[r]=s&&r in t?t[r]:this._objectIdGenerator()}async _checkProjection(e){try{await F(_,e)}catch{throw new g("geojson-layer","Projection not supported")}}}export{ft as default};
